<template>
  <div class="chat-content-container" :class="{ 'theme-dark': currentTheme === 'dark', 'theme-light': currentTheme === 'light' }">
    <!-- Chat Header -->
    <div class="chat-header">
      <!-- üì± Mobile Sidebar Button -->
      <button 
        v-if="isMobile" 
        @click="toggleMobileSidebar" 
        class="mobile-sidebar-btn"
        title="Open Sidebar"
      >
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor">
          <line x1="3" y1="6" x2="21" y2="6"></line>
          <line x1="3" y1="12" x2="21" y2="12"></line>
          <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
      </button>
      
      <div class="chat-header-info">
        <div class="chat-title">
          <span v-if="currentChat?.chat_type === 'PublicChannel'" class="channel-prefix">#</span>
          <span v-else-if="currentChat?.chat_type === 'PrivateChannel'" class="channel-prefix">üîí</span>
          <h1>{{ getDisplayChatName() }}</h1>
        </div>
        <div class="chat-description">
          {{ getDisplayChatDescription() }}
        </div>
      </div>

      <div class="chat-header-actions elegant">
        <!-- Invite Members Button -->
        <button 
          v-if="showInviteButton" 
          class="header-action elegant-invite" 
          @click="openInviteMembers"
          title="Invite members to this chat"
        >
          <Icon name="user-plus" class="action-icon" />
          <span class="action-text">Invite</span>
        </button>
        
        <!-- Search Button -->
        <button class="header-action elegant-search" @click="openPerfectSearch">
          <svg class="golden-search-icon" width="20" height="20" viewBox="0 0 100 100" fill="none">
            <circle cx="38.2" cy="38.2" r="23.6" stroke="currentColor" stroke-width="6.18" fill="none" stroke-linecap="round" />
            <line x1="55.9" y1="55.9" x2="76.4" y2="76.4" stroke="currentColor" stroke-width="6.18" stroke-linecap="round" />
            <circle cx="32.4" cy="32.4" r="4.8" fill="currentColor" opacity="0.3" />
          </svg>
          <span class="action-text">Search</span>
        </button>

        <!-- Chat Actions Dropdown -->
        <div class="chat-actions-container" ref="chatActionsContainer">
          <button class="header-action elegant-btn" @click="toggleChatMenu" title="Chat settings">
            <Icon name="settings" class="action-icon" />
          </button>
          <Transition name="menu-slide-down">
            <div v-if="showChatMenu" class="chat-actions-menu">
              <button @click="openMemberManagement" class="menu-item">
                <Icon name="users" class="menu-icon" />
                <span>Members</span>
              </button>
              <button @click="openChatSettings" class="menu-item">
                <Icon name="settings" class="menu-icon" />
                <span>Settings</span>
              </button>
              <div class="menu-divider"></div>
              <button @click="leaveChannel" class="menu-item menu-item-danger">
                <Icon name="log-out" class="menu-icon" />
                <span>Leave Channel</span>
              </button>
            </div>
          </Transition>
        </div>
      </div>
    </div>

    <!-- Messages Container -->
    <div class="messages-container" :class="{ 'has-input-preview': hasInputPreview }">
      <!-- Discord Message List Component -->
      <DiscordMessageList 
        v-if="currentChatId" 
        :chat-id="currentChatId" 
        :current-user-id="authStore.user?.id || 0"
        :messages="chatStore.messages" 
        :loading="chatStore.loading" 
        :has-more-messages="chatStore.hasMoreMessages"
        :typing-users="[]" 
        @load-more-messages="handleLoadMoreMessages"
        @user-profile-opened="handleUserProfileOpened" 
        @dm-created="handleDMCreated" 
        @reply-to="handleReplyTo"
        @edit-message="handleEditMessage" 
        @delete-message="handleDeleteMessage"
        @scroll-position-changed="handleScrollPositionChanged"
        @reading-position-updated="handleReadingPositionUpdated" 
      />
      <div v-else class="messages-loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading chat messages...</div>
      </div>
    </div>

    <!-- Message Input -->
    <div class="input-container">
      <MessageInput 
        v-if="currentChatId" 
        :chat-id="currentChatId" 
        :current-user-id="authStore.user?.id || 0"
        @message-sent="handleMessageSent" 
        @error="handleMessageError" 
        class="message-input" 
      />
      <div v-else class="loading-input">
        <div class="loading-message">Loading chat...</div>
      </div>
    </div>

    <!-- Perfect Search Modal -->
    <PerfectSearchModal 
      v-if="showPerfectSearch" 
      :is-open="showPerfectSearch" 
      :chat-id="currentChatId"
      @close="handlePerfectSearchClose" 
      @navigate="handlePerfectSearchNavigate" 
    />

    <!-- Member Management Modal -->
    <div v-if="showMemberManagement" class="chat-modal-overlay" @click="showMemberManagement = false">
      <div class="chat-modal chat-modal-large" @click.stop>
        <div class="chat-modal-header">
          <h3>Manage Members</h3>
          <button class="chat-modal-close" @click="showMemberManagement = false">√ó</button>
        </div>
        <div class="chat-modal-content">
          <MemberManagement :chat-id="currentChatId" :chat="currentChat" @member-updated="handleMemberUpdated" />
        </div>
      </div>
    </div>

    <!-- ChatSettings Modal -->
    <div v-if="showChatSettings" class="chat-modal-overlay" @click="showChatSettings = false">
      <div class="chat-modal" @click.stop>
        <div class="chat-modal-header">
          <h3>Chat Settings</h3>
          <button class="chat-modal-close" @click="showChatSettings = false">√ó</button>
        </div>
        <div class="chat-modal-content">
          <ChatSettings :chat="currentChat" @close="showChatSettings = false" @save="handleChatSettingsUpdate" />
        </div>
      </div>
    </div>

    <!-- Invite Members Modal -->
    <InviteMemberModal 
      v-if="showInviteMembersModal"
      :is-open="showInviteMembersModal"
      :chat-id="currentChatId"
      :chat-name="getDisplayChatName()"
      :existing-member-ids="[]"
      @close="showInviteMembersModal = false"
      @members-invited="handleMembersInvited"
    />

    <!-- UserProfileModal -->
    <UserProfile 
      v-if="selectedUserProfile" 
      :user="selectedUserProfile" 
      @close="selectedUserProfile = null"
      @dm-created="handleDMCreated" 
    />

    <!-- Translation Panel -->
    <TranslationPanel 
      v-if="activeTranslationPanel && translationPanelMessage" 
      :visible="!!activeTranslationPanel"
      :message="translationPanelMessage" 
      :position="getOptimalTranslationPanelPosition()"
      @close="handleTranslationPanelClose" 
      @translated="handleTranslationCompleted"
      @applied="handleTranslationApplied" 
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, watch, nextTick } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth.js'
import { useChatStore } from '@/stores/chat.js'
import { useMessageUIStore } from '@/stores/messageUI.js'
import { useChatManagementStore } from '@/stores/chatManagement.js'
import minimalSSE from '@/services/sse-minimal.js'
import { createNavigationEventHelper } from '@/services/NavigationEventManager.js'
import themeManager from '@/services/ThemeManager.js'

// Components - reusing existing components
import Icon from '@/components/icons/BaseIcon.vue'
import MessageInput from '@/components/chat/MessageInput/index.vue'
import DiscordMessageList from '@/components/discord/DiscordMessageList.vue'
import MemberManagement from '@/components/chat/MemberManagement.vue'
import ChatSettings from '@/components/chat/ChatSettings.vue'
import UserProfile from '@/components/modals/UserProfile.vue'
import PerfectSearchModal from '@/components/search/PerfectSearchModal.vue'
import TranslationPanel from '@/components/chat/TranslationPanel.vue'
import InviteMemberModal from '@/components/modals/InviteMemberModal.vue'

// Router and stores
const route = useRoute()
const router = useRouter()
const authStore = useAuthStore()
const chatStore = useChatStore()
const messageUIStore = useMessageUIStore()
const chatManagementStore = useChatManagementStore()

// üéØ Initialize navigation event manager for Chat.vue
const navigationHelper = createNavigationEventHelper(router)

// üéØ Setup navigation event listeners
navigationHelper.addEventListener('navigation-complete', (result) => {
  console.log('üéâ [Chat.vue] Navigation completed via NavigationEventManager:', result)
  
  // Update current chat ID to match the successful navigation
  if (result.chatId && result.chatId !== currentChatId.value) {
    currentChatId.value = result.chatId
    chatStore.currentChatId = result.chatId
  }
})

navigationHelper.addEventListener('navigation-error', (error) => {
  console.error('‚ùå [Chat.vue] Navigation error via NavigationEventManager:', error)
  
  // Could show user notification here
  if (typeof window !== 'undefined' && window.showNotification) {
    window.showNotification(`Navigation failed: ${error.error}`, 'error')
  }
})

// State - core chat functionality
const initChatId = () => {
  const routeId = route.params.id
  if (routeId && !isNaN(parseInt(routeId))) {
    return parseInt(routeId)
  }
  console.warn('‚ö†Ô∏è Invalid or missing chat ID in route:', routeId)
  return null
}

const currentChatId = ref(initChatId())
const selectedUserProfile = ref(null)
const replyToMessage = ref(null)
const showPerfectSearch = ref(false)
const showMemberManagement = ref(false)
const showChatSettings = ref(false)
const showInviteMembersModal = ref(false)
const hasInputPreview = ref(false)
const showChatMenu = ref(false)
const chatActionsContainer = ref(null)

// üé® Theme management - ÈªòËÆ§ÊµÖËâ≤‰∏ªÈ¢òÔºå‰∏éÂÖ®Â±ÄÁ≥ªÁªüÂêåÊ≠•
const currentTheme = ref(themeManager.getCurrentTheme() || 'light')
let handleThemeChange = null

// Á°Æ‰øù‰∏ªÈ¢òÊúâÊïà‰∏îÈªòËÆ§‰∏∫ÊµÖËâ≤
const effectiveTheme = computed(() => {
  return ['light', 'dark'].includes(currentTheme.value) ? currentTheme.value : 'light'
})

// ÁõëÂê¨‰∏ªÈ¢òÂèòÂåñÔºåÁ°Æ‰øù‰∏éÂÖ®Â±Ä‰∏ªÈ¢òÁ≥ªÁªüÂêåÊ≠•
watch(() => themeManager.getCurrentTheme(), (newTheme) => {
  if (currentTheme.value !== newTheme) {
    currentTheme.value = newTheme || 'light'
    console.log('üé® [Chat.vue] Theme synchronized with global system:', currentTheme.value)
  }
})

// üì± Mobile detection and sidebar control
const isMobile = ref(false)
const keyboardVisible = ref(false)
const originalViewportHeight = ref(0)
const currentViewportHeight = ref(0)

const checkIsMobile = () => {
  isMobile.value = window.innerWidth <= 768
}

// üì± ÈîÆÁõòÊ£ÄÊµãÂíåÈÄÇÈÖç
const detectKeyboard = () => {
  if (!isMobile.value) return
  
  const currentHeight = window.visualViewport?.height || window.innerHeight
  const originalHeight = originalViewportHeight.value || window.screen.height
  
  // ÈîÆÁõòÈ´òÂ∫¶ÈòàÂÄºÔºöÂ¶ÇÊûúËßÜÂè£È´òÂ∫¶ÂáèÂ∞ëË∂ÖËøá150pxÔºåËÆ§‰∏∫ÈîÆÁõòÂ∑≤ÊòæÁ§∫
  const keyboardThreshold = 150
  const heightDifference = originalHeight - currentHeight
  
  const wasKeyboardVisible = keyboardVisible.value
  keyboardVisible.value = heightDifference > keyboardThreshold
  
  currentViewportHeight.value = currentHeight
  
  if (wasKeyboardVisible !== keyboardVisible.value) {
    console.log('üì± [Chat.vue] Keyboard state changed:', {
      visible: keyboardVisible.value,
      originalHeight,
      currentHeight,
      heightDifference,
      threshold: keyboardThreshold
    })
    
    // Â∫îÁî®ÈîÆÁõòÈÄÇÈÖçÊ†∑Âºè
    applyKeyboardAdaptation()
  }
}

// üì± Â∫îÁî®ÈîÆÁõòÈÄÇÈÖç
const applyKeyboardAdaptation = () => {
  const chatContainer = document.querySelector('.chat-content-container')
  const inputContainer = document.querySelector('.input-container')
  const messagesContainer = document.querySelector('.messages-container')
  
  if (!chatContainer || !inputContainer || !messagesContainer) return
  
  if (keyboardVisible.value) {
    // ÈîÆÁõòÊòæÁ§∫Êó∂ÁöÑÈÄÇÈÖç
    console.log('üì± [Chat.vue] Applying keyboard visible adaptations')
    
    // üîß FIX: ‰ΩøÁî®CSSÂèòÈáèËÄå‰∏çÊòØÁõ¥Êé•ËÆæÁΩÆÈ´òÂ∫¶
    // ËÆæÁΩÆÂÆπÂô®È´òÂ∫¶‰∏∫ÂΩìÂâçËßÜÂè£È´òÂ∫¶
    chatContainer.style.setProperty('--keyboard-height', `${originalViewportHeight.value - currentViewportHeight.value}px`)
    chatContainer.style.setProperty('--viewport-height', `${currentViewportHeight.value}px`)
    
    // Ê∑ªÂä†ÈîÆÁõòÂèØËßÅÊ†áËØÜ
    chatContainer.classList.add('keyboard-visible')
    
  } else {
    // ÈîÆÁõòÈöêËóèÊó∂ÊÅ¢Â§çÊ≠£Â∏∏
    console.log('üì± [Chat.vue] Applying keyboard hidden adaptations')
    
    // ÁßªÈô§CSSÂèòÈáè
    chatContainer.style.removeProperty('--keyboard-height')
    chatContainer.style.removeProperty('--viewport-height')
    
    // ÁßªÈô§ÈîÆÁõòÂèØËßÅÊ†áËØÜ
    chatContainer.classList.remove('keyboard-visible')
  }
}

// üì± ÊªöÂä®Âà∞ËæìÂÖ•Ê°ÜÔºàÂΩìÈîÆÁõòÂºπÂá∫Êó∂Ôºâ
const scrollToInput = () => {
  if (!keyboardVisible.value || !isMobile.value) return
  
  setTimeout(() => {
    const inputContainer = document.querySelector('.input-container')
    if (inputContainer) {
      inputContainer.scrollIntoView({ 
        behavior: 'smooth', 
        block: 'end',
        inline: 'nearest'
      })
    }
  }, 100)
}

const toggleMobileSidebar = () => {
  console.log('üì± [Chat.vue] Toggling mobile sidebar')
  
  // ‰ºòÂÖà‰ΩøÁî®ÂÖ®Â±ÄÁöÑÁßªÂä®Á´ØÊªëÂä®ÁÆ°ÁêÜÂô®
  if (window.mobileSwipeManager && window.mobileSwipeManager.toggleSidebar) {
    window.mobileSwipeManager.toggleSidebar()
    console.log('üì± [Chat.vue] Using global mobile swipe manager')
    return
  }
  
  // Â§áÁî®ÊñπÊ°àÔºöÁõ¥Êé•Êìç‰ΩúDOM
  console.log('üì± [Chat.vue] Fallback to direct DOM manipulation')
  const sidebar = document.querySelector('.global-sidebar.mobile-sidebar')
  const overlay = document.querySelector('.mobile-overlay')
  
  if (sidebar) {
    const isVisible = sidebar.classList.contains('mobile-visible')
    
    if (isVisible) {
      // ÂÖ≥Èó≠sidebar
      sidebar.classList.remove('mobile-visible')
      sidebar.style.transform = 'translateX(-100%)'
      if (overlay) {
        overlay.remove()
      }
      document.body.style.overflow = ''
      console.log('üì± [Chat.vue] Sidebar closed via fallback')
    } else {
      // ÊâìÂºÄsidebar
      sidebar.classList.add('mobile-visible')
      sidebar.style.transform = 'translateX(0)'
      
      // Ê∑ªÂä†ÈÅÆÁΩ©Â±Ç
      if (!overlay) {
        const newOverlay = document.createElement('div')
        newOverlay.className = 'mobile-overlay'
        newOverlay.addEventListener('click', () => {
          sidebar.classList.remove('mobile-visible')
          sidebar.style.transform = 'translateX(-100%)'
          newOverlay.remove()
          document.body.style.overflow = ''
          console.log('üì± [Chat.vue] Sidebar closed via overlay click')
        })
        document.body.appendChild(newOverlay)
      }
      
      document.body.style.overflow = 'hidden'
      console.log('üì± [Chat.vue] Sidebar opened via fallback')
    }
  } else {
    console.warn('üì± [Chat.vue] Sidebar element not found')
  }
}

// Computed - with safe fallbacks
const currentChat = computed(() => chatStore.getCurrentChat)

// üîß ENHANCED: Show invite button for group chats and channels
const showInviteButton = computed(() => {
  if (!currentChat.value && !currentChatId.value) return false;
  
  // Check cached details first
  const cachedDetails = chatManagementStore.getCachedChatDetails(currentChatId.value);
  if (cachedDetails) {
    return ['PublicChannel', 'PrivateChannel', 'Group'].includes(cachedDetails.type);
  }
  
  // Fallback to current chat data
  if (currentChat.value) {
    return ['PublicChannel', 'PrivateChannel', 'Group'].includes(currentChat.value.chat_type);
  }
  
  return false;
})

// Translation panel integration
const activeTranslationPanel = computed(() => messageUIStore.activeTranslationPanel)
const translationPanelMessage = computed(() => {
  if (!activeTranslationPanel.value) return null
  const messageId = activeTranslationPanel.value.messageId
  return chatStore.messages.find(msg => msg.id === messageId)
})

// Optimized loading prevention
let loadingInProgress = false

// üö® DISABLED: Route-level scroll enforcement system
// ÂéüÂõ†Ôºö‰∏éDiscordMessageListÂíåUnifiedScrollManager‰∫ßÁîüÁ´û‰∫âÊù°‰ª∂
// Ëß£ÂÜ≥ÊñπÊ°àÔºöËÆ©‰∏ìÈó®ÁöÑÊªöÂä®ÁªÑ‰ª∂ÂÖ®ÊùÉË¥üË¥£ÊªöÂä®ÁÆ°ÁêÜ
let routeScrollEnforcementDisabled = true; // üî¥ PERMANENTLY DISABLED
let routeScrollEnforcementPaused = false;
let routeScrollPauseReason = '';
let routeScrollPausedForChat = null;

// Global pause/resume functions for UnifiedScrollManager integration (kept for compatibility)
window.pauseRouteScrollEnforcement = (chatId, reason) => {
  routeScrollEnforcementPaused = true;
  routeScrollPauseReason = reason;
  routeScrollPausedForChat = chatId;
  console.log(`üö® [ROUTE SCROLL] PAUSED for chat ${chatId} - reason: ${reason} (DISABLED)`);
};

window.resumeRouteScrollEnforcement = (chatId) => {
  if (routeScrollPausedForChat === chatId || !routeScrollPausedForChat) {
    routeScrollEnforcementPaused = false;
    routeScrollPauseReason = '';
    routeScrollPausedForChat = null;
    console.log(`üö® [ROUTE SCROLL] RESUMED for chat ${chatId} (DISABLED)`);
  }
};

// Discord Message List Event Handlers
const handleLoadMoreMessages = async () => {
  if (!currentChatId.value || chatStore.loading || !chatStore.hasMoreMessages || loadingInProgress) {
    console.log('‚è∏Ô∏è Load more blocked:', {
      chatId: currentChatId.value,
      loading: chatStore.loading,
      hasMore: chatStore.hasMoreMessages,
      inProgress: loadingInProgress
    })
    // üéØ CRITICAL: ËøîÂõû‰∏Ä‰∏™resolved PromiseÔºåÈÅøÂÖçundefined.thenÈîôËØØ
    return Promise.resolve([])
  }

  loadingInProgress = true

  try {
    console.log('üì• Loading more messages for chat:', currentChatId.value)
    const result = await chatStore.fetchMoreMessages(currentChatId.value)
    // üéØ CRITICAL: ËøîÂõûÂÆûÈôÖÁªìÊûú‰æõAPIÁîüÂëΩÂë®ÊúüÊ£ÄÊµãÂô®‰ΩøÁî®
    return result || []
  } catch (error) {
    console.error('Failed to load more messages:', error)
    // üéØ CRITICAL: ÈîôËØØÊÉÖÂÜµ‰∏ã‰πüË¶ÅËøîÂõûPromiseÔºåÈÅøÂÖçundefined.thenÈîôËØØ
    throw error
  } finally {
    setTimeout(() => {
      loadingInProgress = false
    }, 500)
  }
}

const handleUserProfileOpened = (user) => {
  selectedUserProfile.value = user
}

const handleDMCreated = async (chat) => {
  console.log('üî• DM Created:', chat)
  selectedUserProfile.value = null

  if (chat && chat.id) {
    try {
      await router.push(`/chat/${chat.id}`)
      console.log('‚úÖ Successfully navigated to DM:', chat.id)
    } catch (error) {
      console.error('‚ùå Failed to navigate to DM:', error)
      window.location.href = `/chat/${chat.id}`
    }
  } else {
    console.error('‚ùå Invalid chat object received:', chat)
  }
}

const handleReplyTo = (message) => {
  replyToMessage.value = message
}

const handleEditMessage = (message) => {
  console.log('Edit message:', message.id)
}

const handleDeleteMessage = (message) => {
  console.log('Delete message:', message.id)
}

const handleScrollPositionChanged = (position) => {
  console.log('Scroll position changed:', position)
}

const handleReadingPositionUpdated = (position) => {
  console.log('Reading position updated:', position)
}

// SSE Listener Lifecycle Management - Redesigned for stability
const ensureSSEListeners = async () => {
  try {
    console.log('üîó [Chat.vue] Ensuring SSE listeners for real-time chat...')

    // üîß CRITICAL: Multi-layer authentication check
    const authChecks = {
      isAuthenticated: authStore.isAuthenticated,
      hasToken: !!authStore.token,
      hasUser: !!authStore.user,
      tokenLength: authStore.token?.length || 0,
      userId: authStore.user?.id
    }

    console.log('üîç [SSE] Authentication status:', authChecks)

    if (!authChecks.isAuthenticated || !authChecks.hasToken || !authChecks.hasUser) {
      console.warn('‚ö†Ô∏è [SSE] Incomplete authentication state, skipping SSE connection', authChecks)
      return false
    }

    // üîß ENHANCED: Check if we're actually in a chat context
    if (!currentChatId.value) {
      console.log('‚ÑπÔ∏è [SSE] No current chat ID, deferring SSE connection until chat is loaded')
      return false
    }

    if (!minimalSSE) {
      console.error('‚ùå MinimalSSE service not available')
      return false
    }

    const sseStatus = minimalSSE.getStatus?.() || {}
    console.log('üì° [SSE] Current status:', sseStatus)

    if (!sseStatus.connected) {
      console.log('üöÄ [SSE] Initiating connection for chat context...')

      // üîß ENHANCED: Comprehensive token validation
      const token = authStore.token
      const tokenValidation = {
        exists: !!token,
        isString: typeof token === 'string',
        hasLength: token?.length > 30, // JWT tokens are typically longer
        hasJWTFormat: token?.includes('.') && token?.split('.').length === 3,
        notExpired: true // We'll trust the authStore for now
      }

      console.log('üîç [SSE] Token validation:', tokenValidation)

      const isValidToken = Object.values(tokenValidation).every(Boolean)
      if (!isValidToken) {
        console.error('‚ùå [SSE] Token validation failed', tokenValidation)
        return false
      }

      try {
        console.log('üîå [SSE] Connecting with validated token for real-time chat updates...')
        
        // üîß NEW: Add connection timeout
        const connectionPromise = minimalSSE.connect(token)
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('SSE connection timeout')), 10000)
        )
        
        await Promise.race([connectionPromise, timeoutPromise])
        console.log('‚úÖ [SSE] Connection attempt completed')
        
        // üîß ENHANCED: Verify connection with multiple checks
        await new Promise(resolve => setTimeout(resolve, 1500)) // Longer stabilization
        
        const finalStatus = minimalSSE.getStatus?.() || {}
        const isConnected = finalStatus.connected && minimalSSE.isConnected
        
        if (isConnected) {
          console.log('‚úÖ [SSE] Real-time connection verified and ready for chat')
          return true
        } else {
          console.warn('‚ö†Ô∏è [SSE] Connection completed but verification failed', finalStatus)
          return false
        }
      } catch (error) {
        console.error('‚ùå [SSE] Connection failed:', error.message || error)
        return false
      }
    } else {
      console.log('‚úÖ [SSE] Already connected and ready for real-time updates')
      return true
    }

    const listeners = minimalSSE.listeners
    if (listeners && listeners.get) {
      const messageListeners = listeners.get('message') || []
      console.log(`üì® Current message listeners: ${messageListeners.length}`)

      if (messageListeners.length === 0) {
        console.warn('‚ö†Ô∏è No message listeners found, setting up SSE message listeners...')

        if (chatStore.setupSSEMessageListeners) {
          chatStore.setupSSEMessageListeners()
          console.log('‚úÖ SSE message listeners re-registered')

          const verifyListeners = listeners.get('message') || []
          console.log(`üîç Verification: ${verifyListeners.length} message listeners now registered`)

          if (verifyListeners.length === 0) {
            console.error('‚ùå Failed to register SSE message listeners')
            return false
          }
        } else {
          console.error('‚ùå chatStore.setupSSEMessageListeners not available')
          return false
        }
      } else {
        console.log('‚úÖ SSE message listeners already configured')
      }
    } else {
      console.error('‚ùå SSE listeners interface not available')
      return false
    }

    console.log('‚úÖ SSE listeners lifecycle management completed successfully')
    return true

  } catch (error) {
    console.error('‚ùå Error in SSE listeners lifecycle management:', error)
    return false
  }
}

// Chat management - Enhanced error handling and validation
const handleChannelSelected = async (chatId) => {
  if (!chatId) {
    console.warn('‚ö†Ô∏è [Chat.vue] handleChannelSelected called with empty chatId');
    return;
  }

  // Validate and convert chatId
  const numericChatId = parseInt(chatId);
  if (isNaN(numericChatId)) {
    console.error('‚ùå [Chat.vue] Invalid chatId provided:', chatId);
    return;
  }

  // Avoid processing the same chat twice
  if (numericChatId === currentChatId.value) {
    console.log('‚ÑπÔ∏è [Chat.vue] Already on the same chat, skipping navigation:', numericChatId);
    return;
  }

  console.log('üéØ [Chat.vue] Switching to chat:', numericChatId, 'from:', currentChatId.value);

  // Update chat ID state
  currentChatId.value = numericChatId;
  chatStore.currentChatId = numericChatId;

  try {
    console.log('üîÑ [Chat.vue] Loading chat data and messages...');
    await chatStore.navigateToChat(numericChatId);
    console.log('‚úÖ [Chat.vue] Successfully navigated to chat with messages loaded:', numericChatId);
    
    // üî¥ DISABLED: Route-level scroll to bottom enforcement
    // ËÆ©DiscordMessageListÁªÑ‰ª∂Ëá™‰∏ªÂÜ≥ÂÆöÊªöÂä®Ë°å‰∏∫
    console.log('üî¥ [IRON LAW] Route change scroll enforcement DISABLED - delegating to DiscordMessageList')
    
    // üéØ ALTERNATIVE: ÂèëÈÄÅÂª∫ËÆÆ‰ø°Âè∑ËÄå‰∏çÊòØÂº∫Âà∂ÊªöÂä®
    const routeChangeSuggestion = new CustomEvent('fechatter:suggest-scroll-to-bottom', {
      detail: { 
        chatId: numericChatId,
        source: 'Chat.vue-route-watch',
        reason: 'route_change_suggestion',
        priority: 'medium' // ‰∏≠Á≠â‰ºòÂÖàÁ∫ßÂª∫ËÆÆ
      }
    })
    window.dispatchEvent(routeChangeSuggestion)
    console.log('üí° [Chat.vue] Sent route change scroll suggestion to DiscordMessageList');
    
    // üî¥ LEGACY: Route scroll enforcement (DISABLED)
    const enforceRouteScrollToBottom = async () => {
      if (routeScrollEnforcementDisabled) {
        console.log('üî¥ [IRON LAW] Route scroll enforcement permanently disabled');
        return;
      }
      
      // üö® LEGACY CODE (Â∞ÜÂú®‰∏ã‰∏™ÁâàÊú¨Âà†Èô§)
      console.log('‚ö†Ô∏è [IRON LAW] Route scroll enforcement is deprecated');
    }
    
    await enforceRouteScrollToBottom()
    
    // üîß ENHANCED: Load enhanced chat details
    setTimeout(async () => {
      await loadChatDetails(numericChatId);
    }, 100);
    
    // Then ensure SSE is connected for the new chat context
    // Add a small delay to let chat context settle
    setTimeout(async () => {
      const sseConnected = await ensureSSEListeners()
      if (sseConnected) {
        console.log('‚úÖ [Chat.vue] SSE verified for new chat context:', numericChatId)
      } else {
        console.warn('‚ö†Ô∏è [Chat.vue] SSE connection issue for chat:', numericChatId)
      }
      
      // üî¥ DISABLED: Final enforcement after SSE setup
      // ÂèëÈÄÅÊúÄÁªàÂª∫ËÆÆËÄå‰∏çÊòØÂº∫Âà∂ÊªöÂä®
      setTimeout(() => {
        const finalSuggestionEvent = new CustomEvent('fechatter:suggest-scroll-to-bottom', {
          detail: { 
            chatId: numericChatId,
            source: 'Chat.vue-final',
            reason: 'post_sse_suggestion',
            priority: 'low' // ‰Ωé‰ºòÂÖàÁ∫ßÊúÄÁªàÂª∫ËÆÆ
          }
        })
        window.dispatchEvent(finalSuggestionEvent)
        console.log('üí° [Chat.vue] Final route change suggestion completed')
      }, 100)
    }, 300)
  } catch (error) {
    console.error('Failed to switch chat:', error)
  }
}

// Event handlers
const openPerfectSearch = () => {
  showPerfectSearch.value = true
}

const toggleChatMenu = () => {
  showChatMenu.value = !showChatMenu.value
}

const closeChatMenu = () => {
  showChatMenu.value = false
}

const openMemberManagement = () => {
  showMemberManagement.value = true
  closeChatMenu()
}

const openChatSettings = () => {
  showChatSettings.value = true
  closeChatMenu()
}

const leaveChannel = async () => {
  closeChatMenu()
  if (!currentChatId.value) return
  
  const confirmed = confirm(`Are you sure you want to leave "${getDisplayChatName()}"?`)
  if (confirmed) {
    try {
      await chatManagementStore.leaveChat(currentChatId.value)
      router.push('/home') // Redirect to a safe page after leaving
    } catch (error) {
      console.error('Failed to leave channel:', error)
      // You might want to show a notification to the user here
    }
  }
}

const openInviteMembers = () => {
  showInviteMembersModal.value = true
}

const handleMemberUpdated = () => {
  console.log('Member updated')
}

const handleChatSettingsUpdate = () => {
  console.log('Chat settings updated')
  showChatSettings.value = false
}

const handleMembersInvited = async (inviteResult) => {
  console.log('‚úÖ [Chat.vue] Members invited to chat:', inviteResult);
  showInviteMembersModal.value = false;
  
  // üîß ENHANCED: Refresh chat details to get updated member count
  if (currentChatId.value) {
    setTimeout(async () => {
      await loadChatDetails(currentChatId.value);
    }, 1000);
  }
}

// Translation Panel Event Handlers
const handleTranslationPanelClose = () => {
  console.log('üåê Translation panel closed')
  messageUIStore.closeTranslationPanel()
}

const handleTranslationCompleted = (translationResult) => {
  console.log('üåê Translation completed:', translationResult)
}

const handleTranslationApplied = (applicationResult) => {
  console.log('üåê Translation applied:', applicationResult)
}

// Enhanced chat details loading
const loadChatDetails = async (chatId) => {
  if (!chatId) return null;
  
  try {
    console.log('üîç [Chat.vue] Loading enhanced chat details for:', chatId);
    
    // üîß ENHANCED: Get detailed chat information via new API
    const chatDetails = await chatManagementStore.getChatDetails(chatId);
    
    if (chatDetails) {
      console.log('‚úÖ [Chat.vue] Enhanced chat details loaded:', {
        name: chatDetails.name,
        type: chatDetails.type,
        memberCount: chatDetails.member_count,
        isPrivate: chatDetails.is_private
      });
      
      // Update chat store with enhanced details if needed
      const existingChat = chatStore.getChatById(chatId);
      if (existingChat && chatDetails.member_count !== existingChat.member_count) {
        console.log('üîÑ [Chat.vue] Updating chat with enhanced details');
        existingChat.member_count = chatDetails.member_count;
        existingChat.settings = chatDetails.settings;
      }
    }
    
    return chatDetails;
  } catch (error) {
    console.error('‚ùå [Chat.vue] Failed to load enhanced chat details:', error);
    return null;
  }
};

// Chat display utilities
const getDisplayChatName = () => {
  if (!currentChatId.value) return 'Loading...'
  
  // üîß ENHANCED: Check cached chat details first
  const cachedDetails = chatManagementStore.getCachedChatDetails(currentChatId.value);
  if (cachedDetails && cachedDetails.name) {
    return cachedDetails.name;
  }
  
  if (!currentChat.value) {
    const chat = chatStore.getChatById(currentChatId.value)
    if (chat) {
      return chat.display_name || chat.name || `Chat ${currentChatId.value}`
    }
    return 'Loading...'
  }
  
  return currentChat.value.display_name || currentChat.value.name || `Chat ${currentChatId.value}`
}

const getDisplayChatDescription = () => {
  if (!currentChatId.value) return 'Loading chat...'
  
  // üîß ENHANCED: Check cached chat details first
  const cachedDetails = chatManagementStore.getCachedChatDetails(currentChatId.value);
  if (cachedDetails) {
    if (cachedDetails.description) {
      return cachedDetails.description;
    }
    
    // Enhanced description with member count
    const memberText = cachedDetails.member_count ? ` ‚Ä¢ ${cachedDetails.member_count} members` : '';
    
    switch (cachedDetails.type) {
      case 'PublicChannel':
        return `Public channel${memberText}`;
      case 'PrivateChannel':
        return `Private channel${memberText}`;
      case 'Single':
        return 'Direct message';
      case 'Group':
        return `Group chat${memberText}`;
      default:
        return `Chat channel${memberText}`;
    }
  }
  
  if (!currentChat.value) return 'Loading chat information...'
  
  if (currentChat.value.description) {
    return currentChat.value.description
  }
  
  switch (currentChat.value.chat_type) {
    case 'PublicChannel':
      return 'Public channel'
    case 'PrivateChannel':
      return 'Private channel'
    case 'Single':
      return 'Direct message'
    case 'Group':
      return 'Group chat'
    default:
      return 'Chat channel'
  }
}

// Enhanced message sending with file upload support
const handleMessageSent = async (messageData) => {
  if (!currentChatId.value) {
    console.error('‚ùå No chat ID available for handling sent message')
    return
  }

  try {
    console.log('üì® [Chat.vue] Processing message for sending:', {
      chatId: currentChatId.value,
      content: messageData.content || '(empty)',
      contentLength: messageData.content?.length || 0,
      contentTrimmed: messageData.content?.trim() || '(empty)',
      contentTrimmedLength: messageData.content?.trim()?.length || 0,
      filesCount: messageData.files?.length || 0,
      hasFiles: messageData.files?.length > 0,
      messageData: messageData
    })

    // üîß BACKEND ALIGNED: Backend requires content to be non-empty even with files
    // Ê≥®ÊÑèÔºö‰∏çË¶ÅÂÜçÊ¨°trimÔºåÂõ†‰∏∫MessageInputÂèØËÉΩÂ∑≤ÁªèÊ∑ªÂä†‰∫ÜÂøÖË¶ÅÁöÑÁ©∫Ê†º
    const contentToSend = messageData.content || '';
    const hasValidContent = contentToSend.length > 0;
    const hasValidFiles = messageData.files && messageData.files.length > 0;

    // üîß BACKEND REQUIREMENT: Content must always be non-empty
    if (!hasValidContent) {
      console.error('‚ùå [Chat.vue] Message validation failed: Empty content not allowed', {
        originalContent: messageData.content,
        contentToSend: contentToSend,
        files: messageData.files,
        backendRequirement: 'Content must be 1-4000 characters even with files'
      })
      emit('error', {
        type: 'validation',
        message: hasValidFiles 
          ? 'Message content is required even with files (backend requirement)'
          : 'Message content cannot be empty'
      })
      return
    }

    if (contentToSend.length > 4000) {
      console.error('‚ùå [Chat.vue] Message validation failed: Content too long', {
        contentLength: contentToSend.length,
        maxLength: 4000
      })
      emit('error', {
        type: 'validation', 
        message: 'Message content must be less than 4000 characters'
      })
      return
    }

    const sendOptions = {
      formatMode: messageData.formatMode,
      replyTo: messageData.reply_to,
      mentions: messageData.mentions
    }

    let result

    if (hasValidFiles) {
      console.log('üì§ [Chat.vue] Sending message with files using enhanced system', {
        content: contentToSend,
        contentLength: contentToSend.length,
        filesCount: messageData.files.length
      })

      result = await chatStore.sendMessageWithFiles(
        contentToSend, // üîß Use validated content
        messageData.files,
        sendOptions
      )

      console.log('‚úÖ [Chat.vue] File message sent with enhanced system:', {
        messageId: result?.message?.id,
        filesUploaded: result?.message?.files?.length || 0
      })

    } else if (hasValidContent) {
      console.log('üì® [Chat.vue] Sending text-only message', {
        content: contentToSend,
        contentLength: contentToSend.length
      })

      result = await chatStore.sendMessage(contentToSend, sendOptions) // üîß Use validated content

      console.log('‚úÖ [Chat.vue] Text message sent:', {
        messageId: result?.message?.id
      })
    } else {
      console.error('‚ùå [Chat.vue] No valid content or files to send')
      return
    }

    replyToMessage.value = null
    return result

  } catch (error) {
    console.error('‚ùå [Chat.vue] Failed to send message:', error)
    
    // üîß Enhanced error handling with more specific messages
    let errorMessage = 'Failed to send message'
    if (error.response?.status === 400) {
      const errorData = error.response.data
      if (errorData.message?.includes('content')) {
        errorMessage = 'Message content validation failed'
      } else if (errorData.message?.includes('file')) {
        errorMessage = 'File validation failed'
      } else {
        errorMessage = errorData.message || 'Invalid request'
      }
    } else if (error.response?.status === 401) {
      errorMessage = 'Authentication failed. Please login again.'
    } else if (error.response?.status === 403) {
      errorMessage = 'You do not have permission to send messages in this chat'
    } else if (error.response?.status >= 500) {
      errorMessage = 'Server error. Please try again later.'
    }

    emit('error', {
      type: 'send_failed',
      message: errorMessage,
      error
    })
    
    throw error
  }
}

// Handle errors from MessageInput
const handleMessageError = (errorMessage) => {
  console.error('‚ùå [Chat.vue] MessageInput error:', errorMessage)

  if (typeof window !== 'undefined' && window.showNotification) {
    window.showNotification(errorMessage, 'error')
  } else {
    alert(errorMessage)
  }
}

// Lifecycle - Optimized for SSE stability
onMounted(async () => {
  console.log('üî• [Chat.vue] Chat component mounted - initializing real-time system')

  // üé® Initialize theme management
  handleThemeChange = (newTheme) => {
    currentTheme.value = newTheme
    console.log('üé® [Chat.vue] Theme changed to:', newTheme)
  }
  themeManager.addListener(handleThemeChange)

  // üì± Initialize mobile detection
  checkIsMobile()
  window.addEventListener('resize', checkIsMobile)

  // üì± Initialize keyboard detection for mobile
  if (isMobile.value) {
    // ËÆ∞ÂΩïÂàùÂßãËßÜÂè£È´òÂ∫¶
    originalViewportHeight.value = window.innerHeight
    currentViewportHeight.value = window.innerHeight
    
    // ÁõëÂê¨ËßÜÂè£ÂèòÂåñÔºàÈîÆÁõòÂºπÂá∫/Êî∂Ëµ∑Ôºâ
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', detectKeyboard)
      console.log('üì± [Chat.vue] Visual Viewport API available, using for keyboard detection')
    } else {
      // Â§áÁî®ÊñπÊ°àÔºöÁõëÂê¨window resize
      window.addEventListener('resize', detectKeyboard)
      console.log('üì± [Chat.vue] Using window resize for keyboard detection (fallback)')
    }
    
    // ÁõëÂê¨ËæìÂÖ•Ê°ÜËÅöÁÑ¶‰∫ã‰ª∂
    setTimeout(() => {
      const messageInput = document.querySelector('.message-textarea')
      if (messageInput) {
        messageInput.addEventListener('focus', () => {
          console.log('üì± [Chat.vue] Input focused, will check for keyboard')
          setTimeout(detectKeyboard, 300) // Âª∂ËøüÊ£ÄÊµãÔºåÁ≠âÂæÖÈîÆÁõòÂä®Áîª
          setTimeout(scrollToInput, 500) // Âª∂ËøüÊªöÂä®ÔºåÁ°Æ‰øùÈîÆÁõòÂÆåÂÖ®ÊòæÁ§∫
        })
        
        messageInput.addEventListener('blur', () => {
          console.log('üì± [Chat.vue] Input blurred, will check for keyboard')
          setTimeout(detectKeyboard, 300) // Âª∂ËøüÊ£ÄÊµãÔºåÁ≠âÂæÖÈîÆÁõòÂä®Áîª
        })
      }
    }, 1000) // Á≠âÂæÖÁªÑ‰ª∂ÂÆåÂÖ®Âä†ËΩΩ
  }

  try {
    // Step 1: Initialize chat store foundation
    if (!chatStore.isInitialized) {
      console.log('üîÑ [Chat.vue] Initializing chat store...')
      await chatStore.initialize()
    }

    // Step 2: Load chat list for navigation
    if (chatStore.chats.length === 0) {
      console.log('üîÑ [Chat.vue] Fetching chats for sidebar...')
      await chatStore.fetchChats()
    }

    console.log('‚úÖ [Chat.vue] Chat store ready, chats loaded:', chatStore.chats.length)

    // Step 3: Setup current chat context
    const chatId = route.params.id
    if (currentChatId.value) {
      console.log('‚úÖ [Chat.vue] Valid chat ID confirmed on mount:', currentChatId.value)
      chatStore.currentChatId = currentChatId.value
      await handleChannelSelected(currentChatId.value)
    } else {
      console.warn('‚ö†Ô∏è [Chat.vue] No valid chat ID available on mount, route param:', chatId)
    }

    // Step 4: ONLY NOW attempt SSE connection (after chat context is established)
    console.log('üîå [Chat.vue] Chat context ready, setting up real-time connection...')
    
    // Add a small delay to ensure all state is stabilized
    await new Promise(resolve => setTimeout(resolve, 500))
    
    const sseConnected = await ensureSSEListeners()
    if (sseConnected) {
      console.log('‚úÖ [Chat.vue] Real-time connection established for chat updates')
    } else {
      console.warn('‚ö†Ô∏è [Chat.vue] Real-time connection not established, will retry when needed')
    }

    // Ensure SSE connection is established when entering chat
    try {
      if (!minimalSSE.isConnected && authStore.isAuthenticated && authStore.token) {
        console.log('üîÑ [Chat] Initializing SSE connection that was skipped during login');
        await minimalSSE.connect(authStore.token);
        console.log('‚úÖ [Chat] SSE connection established successfully');
      } else if (minimalSSE.isConnected) {
        console.log('‚úÖ [Chat] SSE connection already established');
      } else {
        console.log('‚ö†Ô∏è [Chat] Cannot establish SSE connection - not authenticated');
      }
    } catch (error) {
      console.error('‚ùå [Chat] Failed to establish SSE connection:', error);
    }

  } catch (error) {
    console.error('‚ùå [Chat.vue] Failed to initialize chat system:', error)
  }

  // Step 5: Setup global event listeners
  document.addEventListener('keydown', handleGlobalKeydown)
  document.addEventListener('click', handleClickOutside)
  
  console.log('üéØ [Chat.vue] Chat component fully initialized and ready')
})

onUnmounted(() => {
  console.log('üî• Chat.vue unmounted')
  loadingInProgress = false
  document.removeEventListener('keydown', handleGlobalKeydown)
  document.removeEventListener('click', handleClickOutside)
  
  // üé® Clean up theme listener
  themeManager.removeListener(handleThemeChange)
  
  // üì± Clean up mobile detection
  window.removeEventListener('resize', checkIsMobile)
  
  // üì± Clean up keyboard detection
  if (window.visualViewport) {
    window.visualViewport.removeEventListener('resize', detectKeyboard)
  } else {
    window.removeEventListener('resize', detectKeyboard)
  }
  
  // üì± Clean up input event listeners
  const messageInput = document.querySelector('.message-textarea')
  if (messageInput) {
    messageInput.removeEventListener('focus', detectKeyboard)
    messageInput.removeEventListener('blur', detectKeyboard)
  }
  
  // üì± Reset any keyboard adaptations
  const chatContainer = document.querySelector('.chat-content-container')
  if (chatContainer) {
    chatContainer.classList.remove('keyboard-visible')
    chatContainer.style.height = ''
    chatContainer.style.maxHeight = ''
  }
})

// Global keyboard shortcuts
const handleGlobalKeydown = (event) => {
  if ((event.metaKey || event.ctrlKey) && event.key === 'k') {
    event.preventDefault()
    openPerfectSearch()
  }
}

const handleClickOutside = (event) => {
  if (chatActionsContainer.value && !chatActionsContainer.value.contains(event.target)) {
    closeChatMenu()
  }
}

// Watch route changes - Optimized for stable navigation
watch(
  () => route.params.id,
  async (newChatId, oldChatId) => {
    console.log('üîÑ [Chat.vue] Route changed from', oldChatId, 'to', newChatId);

    if (newChatId && !isNaN(parseInt(newChatId))) {
      const validChatId = parseInt(newChatId);
      
      // ÈÅøÂÖçÈáçÂ§çÂ§ÑÁêÜÁõ∏ÂêåÁöÑchat ID
      if (validChatId === currentChatId.value) {
        console.log('‚ÑπÔ∏è [Chat.vue] Same chat ID, skipping route change handling');
        return;
      }
      
      console.log('üéØ [Chat.vue] Processing chat context switch from', currentChatId.value, 'to', validChatId);
      
      // ÈáçÁΩÆÂä†ËΩΩÁä∂ÊÄÅ
      loadingInProgress = false;
      
      // Êõ¥Êñ∞chat ID
      currentChatId.value = validChatId;
      chatStore.currentChatId = validChatId;
      
      try {
        // ÂàáÊç¢ËÅäÂ§©‰∏ä‰∏ãÊñá
        await handleChannelSelected(validChatId);
        
        console.log('‚úÖ [Chat.vue] Chat context switch completed successfully');
        
        // ÂèëÈÄÅÂØºËà™ÂÆåÊàê‰∫ã‰ª∂
        const navigationCompleteEvent = new CustomEvent('fechatter:navigation-complete', {
          detail: { 
            chatId: validChatId,
            source: 'Chat.vue-route-watch',
            oldChatId: parseInt(oldChatId) || null,
            timestamp: Date.now()
          }
        });
        window.dispatchEvent(navigationCompleteEvent);
        
      } catch (error) {
        console.error('‚ùå [Chat.vue] Failed to switch chat context:', error);
        
        // ÂèëÈÄÅÂØºËà™Â§±Ë¥•‰∫ã‰ª∂
        const navigationErrorEvent = new CustomEvent('fechatter:navigation-error', {
          detail: { 
            chatId: validChatId,
            error: error.message,
            source: 'Chat.vue-route-watch'
          }
        });
        window.dispatchEvent(navigationErrorEvent);
      }
      
    } else {
      console.warn('‚ö†Ô∏è [Chat.vue] Invalid chat ID in route watch:', newChatId);
      currentChatId.value = null;
      chatStore.currentChatId = null;
    }
  },
  { immediate: false } // ‰∏çÁ´ãÂç≥ÊâßË°åÔºåÈÅøÂÖç‰∏éonMountedÂÜ≤Á™Å
)

// Translation Panel position logic
const getOptimalTranslationPanelPosition = () => {
  if (typeof window === 'undefined') {
    return { x: 400, y: 80 }
  }

  const viewportWidth = window.innerWidth
  const viewportHeight = window.innerHeight
  const panelWidth = 420
  const panelHeight = 500
  const topMargin = 80
  const rightMargin = 20
  const messageAreaWidth = Math.min(860, viewportWidth * 0.7)

  const messageAreaLeft = (viewportWidth - messageAreaWidth) / 2
  const messageAreaRight = messageAreaLeft + messageAreaWidth

  let left, top

  if (viewportWidth - messageAreaRight >= panelWidth + rightMargin) {
    left = messageAreaRight + 16
  } else if (messageAreaLeft >= panelWidth + rightMargin) {
    left = messageAreaLeft - panelWidth - 16
  } else {
    left = viewportWidth - panelWidth - rightMargin
  }

  top = topMargin

  left = Math.max(rightMargin, Math.min(left, viewportWidth - panelWidth - rightMargin))
  top = Math.max(topMargin, Math.min(top, viewportHeight - panelHeight - 20))

  return { x: left, y: top }
}

const handlePerfectSearchClose = () => {
  showPerfectSearch.value = false
}

const handlePerfectSearchNavigate = (navigationResult) => {
  console.log('üéØ Perfect Search navigation:', navigationResult)
  showPerfectSearch.value = false

  if (navigationResult.chatId && navigationResult.chatId !== currentChatId.value) {
    router.push(`/chat/${navigationResult.chatId}`)
  }
}

console.log('‚úÖ Chat.vue fully restored with all components:', currentChatId.value)
</script>

<style scoped>
.chat-content-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  /* üîß FIX: ‰ΩøÁî®100%ÁªßÊâøÁà∂ÂÆπÂô®È´òÂ∫¶ÔºåÈÅøÂÖçÂ§öÂ±ÇvhÂµåÂ•ó */
  overflow: hidden;
  background: var(--color-background);
  position: relative;
  transition: background-color 0.3s ease;
}

/* üé® Âèå‰∏ªÈ¢òÁ≥ªÁªüÊîØÊåÅ - Á°Æ‰øùÊµÖËâ≤‰∏ªÈ¢ò‰∏∫ÈªòËÆ§ */
.chat-content-container.theme-light {
  /* üåü ÊµÖËâ≤‰∏ªÈ¢òÔºàÈªòËÆ§Ôºâ - Âü∫‰∫éDiscord‰∫ÆËâ≤‰∏ªÈ¢ò */
  --color-background: #ffffff;
  --color-background-secondary: #f2f3f5;
  --color-text: #060607;
  --color-text-secondary: #4e5058;
  --color-text-muted: #6b7280;
  --color-border: #e3e5e8;
  --color-primary: #5865f2;
  --color-primary-hover: #4752c4;
}

.chat-content-container.theme-dark {
  /* üåô ÊöóËâ≤‰∏ªÈ¢ò - Âü∫‰∫éDiscordÊöóËâ≤‰∏ªÈ¢ò */
  --color-background: #36393f;
  --color-background-secondary: #2f3136;
  --color-text: #dcddde;
  --color-text-secondary: #b9bbbe;
  --color-text-muted: #8e9297;
  --color-border: #202225;
  --color-primary: #5865f2;
  --color-primary-hover: #4752c4;
}

.chat-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid var(--color-border);
  background: var(--color-background-secondary);
  flex-shrink: 0;
  transition: background-color 0.3s ease, border-color 0.3s ease;
}

.chat-header-info {
  flex: 1;
  min-width: 0;
}

.chat-title {
  display: flex;
  align-items: center;
  margin-bottom: 2px;
}

.channel-prefix {
  font-size: 16px;
  margin-right: 6px;
  color: var(--color-text-secondary);
}

.chat-title h1 {
  font-size: 18px;
  font-weight: 900;
  color: var(--color-text);
  margin: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.chat-description {
  font-size: 13px;
  color: #616061;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.chat-header-actions {
  display: flex;
  align-items: center;
  gap: 8px;
  position: relative;
}

.chat-actions-container {
  position: relative;
}

.chat-actions-menu {
  position: absolute;
  top: calc(100% + 8px);
  right: 0;
  width: 220px;
  background-color: var(--color-background-secondary);
  border-radius: 8px;
  box-shadow: var(--shadow-lg);
  z-index: 10;
  border: 1px solid var(--color-border);
  overflow: hidden;
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.menu-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 6px;
  color: var(--color-text);
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.15s ease;
  background-color: transparent;
  border: none;
  text-align: left;
  width: 100%;
}

.menu-item:hover {
  background-color: var(--color-background-muted);
}

.menu-icon {
  width: 16px;
  height: 16px;
  color: var(--color-text-muted);
}

.menu-divider {
  height: 1px;
  background-color: var(--color-border);
  margin: 4px 0;
}

.menu-item-danger {
  color: var(--color-danger);
}

.menu-item-danger:hover {
  background-color: var(--color-danger);
  color: white;
}

.menu-item-danger:hover .menu-icon {
  color: white;
}

.menu-slide-down-enter-active,
.menu-slide-down-leave-active {
  transition: opacity 0.15s ease, transform 0.15s ease;
}

.menu-slide-down-enter-from,
.menu-slide-down-leave-to {
  opacity: 0;
  transform: translateY(-10px);
}

.header-action {
  width: 40px;
  height: 40px;
  padding: 8px;
  background: #f0f0f0;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  color: #616061;
  transition: all 0.2s ease;
}

.header-action:hover {
  background-color: #e8f4fd;
  color: #1d1c1d;
}

.messages-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  padding: 20px;
}

.messages-content {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}

.loading-messages {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #616061;
  font-size: 14px;
}

.loading-spinner {
  width: 24px;
  height: 24px;
  border: 3px solid #e1e5e9;
  border-top: 3px solid #2563eb;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin-bottom: 12px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.messages-loading {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}

.loading-text {
  color: #616061;
  font-size: 14px;
}

.input-container {
  flex-shrink: 0;
  border-top: 1px solid #e1e5e9;
  background: white;
  padding: 16px;
}

.chat-header-actions.elegant {
  display: flex;
  align-items: center;
  gap: 8px;
}

.elegant-search {
  background-color: #f6f6f6;
  padding: 8px 12px;
  gap: 8px;
  border-radius: 8px;
  transition: all 0.2s ease;
}

.elegant-search:hover {
  background-color: #e8f4fd;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(0, 122, 255, 0.15);
}

.elegant-invite {
  background-color: rgba(34, 197, 94, 0.1);
  color: #22c55e;
  border: 1px solid rgba(34, 197, 94, 0.2);
  padding: 8px 12px;
  gap: 8px;
  border-radius: 8px;
  transition: all 0.2s ease;
}

.elegant-invite:hover {
  background-color: rgba(34, 197, 94, 0.15);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(34, 197, 94, 0.15);
}

.elegant-btn {
  width: 36px;
  height: 36px;
}

.action-icon {
  width: 20px;
  height: 20px;
}

.golden-search-icon {
  transition: all 0.2s ease;
  color: inherit;
}

.golden-search-icon:hover {
  transform: scale(1.1);
}

.elegant-search:hover .golden-search-icon {
  color: #007AFF;
}

.has-input-preview {
  transform: translateY(-150px);
}

.message-input {
  width: 100%;
}

.loading-input {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  color: #616061;
  background: #f8f9fa;
  border-radius: 8px;
  border: 1px solid #e1e5e9;
}

.loading-message {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.loading-message::before {
  content: "";
  width: 16px;
  height: 16px;
  border: 2px solid #e1e5e9;
  border-top: 2px solid #2563eb;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

/* Modals */
.chat-modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.4);
  backdrop-filter: blur(8px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  padding: 20px;
}

.chat-modal {
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 24px;
  max-width: 600px;
  width: 100%;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  border: none;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.12);
}

.chat-modal-large {
  max-width: 800px;
}

.chat-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 20px 24px;
  border-bottom: none;
  background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(248, 250, 252, 0.6));
  border-radius: 24px 24px 0 0;
}

.chat-modal-header h3 {
  font-size: 18px;
  font-weight: 700;
  color: #1d1c1d;
  margin: 0;
}

.chat-modal-close {
  background: rgba(255, 255, 255, 0.6);
  border: none;
  cursor: pointer;
  color: #616061;
  padding: 8px;
  border-radius: 16px;
  transition: all 0.3s ease;
  backdrop-filter: blur(10px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
}

.chat-modal-close:hover {
  background: rgba(255, 255, 255, 0.9);
  color: #1d1c1d;
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
}

.chat-modal-content {
  flex: 1;
  overflow-y: auto;
  padding: 24px;
}

/* üì± ÁßªÂä®Á´ØÂ∏ÉÂ±Ä‰ºòÂåñ */
@media (max-width: 768px) {
  .chat-content-container {
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    /* üì± ÁßªÂä®Á´ØÁã¨Âç†ÂÖ®Â±è */
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: white;
    z-index: 1;
  }

  /* üì± ÁßªÂä®Á´ØËÅäÂ§©Â§¥ÈÉ® */
  .chat-header {
    height: 56px;
    min-height: 56px;
    padding: 0 16px;
    border-bottom: 1px solid #e5e7eb;
    background: white;
    /* üì± Âõ∫ÂÆöÂ§¥ÈÉ® */
    position: sticky;
    top: 0;
    z-index: 10;
    /* üì± Èò≤Ê≠¢ÊªöÂä®Á©øÈÄè */
    overflow: hidden;
  }

  .chat-header-info {
    flex: 1;
    min-width: 0;
  }

  .chat-title {
    margin-bottom: 2px;
  }

  .chat-title h1 {
    font-size: 16px;
    font-weight: 600;
    margin: 0;
    /* üì± ÁßªÂä®Á´ØÊñáÊú¨Êà™Êñ≠ */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .chat-description {
    font-size: 12px;
    color: #6b7280;
    /* üì± ÁßªÂä®Á´ØÊèèËø∞Êà™Êñ≠ */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .chat-header-actions {
    gap: 6px;
    /* üì± Á°Æ‰øùÊåâÈíÆÁªÑÂêàÈÄÇÁöÑÈó¥Ë∑ù */
    align-items: center;
  }

  .header-action {
    width: 40px;
    height: 40px;
    padding: 8px;
    /* üì± Ëß¶Êë∏ÂèãÂ•ΩÁöÑÊåâÈíÆ */
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: manipulation;
    /* üì± Âü∫Á°ÄÊ†∑ÂºèÈáçÁΩÆ */
    border-radius: 12px;
    transition: all 0.2s ease;
  }

  .header-action .action-text {
    display: none; /* üì± ÁßªÂä®Á´ØÈöêËóèÊñáÊú¨ */
  }

  /* üì± ÁßªÂä®Á´ØÊêúÁ¥¢ÊåâÈíÆ‰ºòÂåñ */
  .elegant-search {
    /* üì± ÊêúÁ¥¢ÊåâÈíÆÁßªÂä®Á´ØÊ†∑Âºè */
    background: rgba(99, 102, 241, 0.1) !important;
    color: #6366f1 !important;
    border: 1px solid rgba(99, 102, 241, 0.2) !important;
    border-radius: 12px !important;
    padding: 10px !important;
    /* üì± Á°Æ‰øùË∂≥Â§üÁöÑËß¶Êë∏ÁõÆÊ†á */
    min-width: 48px !important;
    min-height: 48px !important;
    /* üì± Ëß¶Êë∏ÂèçÈ¶à */
    transition: all 0.2s ease;
    transform: translateZ(0);
  }

  .elegant-search:hover,
  .elegant-search:active {
    background: rgba(99, 102, 241, 0.2) !important;
    border-color: rgba(99, 102, 241, 0.4) !important;
    transform: scale(1.05);
  }

  .elegant-search:active {
    transform: scale(0.95);
  }

  /* üì± ÊêúÁ¥¢ÂõæÊ†áÁßªÂä®Á´Ø‰ºòÂåñ */
  .elegant-search .golden-search-icon {
    width: 22px !important;
    height: 22px !important;
    stroke-width: 2.5 !important;
    color: #6366f1 !important;
  }

  /* üì± ÈÇÄËØ∑ÊåâÈíÆÁßªÂä®Á´Ø‰ºòÂåñ */
  .elegant-invite {
    background: rgba(34, 197, 94, 0.1) !important;
    color: #22c55e !important;
    border: 1px solid rgba(34, 197, 94, 0.2) !important;
    border-radius: 12px !important;
    padding: 10px !important;
    min-width: 48px !important;
    min-height: 48px !important;
    transition: all 0.2s ease;
  }

  .elegant-invite:hover,
  .elegant-invite:active {
    background: rgba(34, 197, 94, 0.2) !important;
    border-color: rgba(34, 197, 94, 0.4) !important;
    transform: scale(1.05);
  }

  .elegant-invite:active {
    transform: scale(0.95);
  }

  .elegant-invite .action-text {
    display: none; /* üì± ÁßªÂä®Á´ØÈöêËóèÊñáÊú¨ */
  }

  /* üì± ËÆæÁΩÆÊåâÈíÆÁßªÂä®Á´Ø‰ºòÂåñ */
  .elegant-btn {
    background: rgba(107, 114, 128, 0.1) !important;
    color: #6b7280 !important;
    border: 1px solid rgba(107, 114, 128, 0.2) !important;
    border-radius: 12px !important;
    padding: 10px !important;
    min-width: 48px !important;
    min-height: 48px !important;
    transition: all 0.2s ease;
  }

  .elegant-btn:hover,
  .elegant-btn:active {
    background: rgba(107, 114, 128, 0.2) !important;
    border-color: rgba(107, 114, 128, 0.4) !important;
    transform: scale(1.05);
  }

  .elegant-btn:active {
    transform: scale(0.95);
  }

  .elegant-btn .action-icon {
    width: 20px !important;
    height: 20px !important;
  }

  /* üì± ÁßªÂä®Á´ØÊ∂àÊÅØÂÆπÂô® */
  .messages-container {
    flex: 1;
    overflow: hidden;
    /* üì± Á°Æ‰øùÊ∂àÊÅØÂå∫ÂüüÂèØÊªöÂä® */
    position: relative;
    background: white;
    /* üì± ÂêØÁî®Á°¨‰ª∂Âä†ÈÄü */
    transform: translateZ(0);
    -webkit-overflow-scrolling: touch;
  }

  .messages-container.has-input-preview {
    /* üì± ËæìÂÖ•È¢ÑËßàÊó∂Ë∞ÉÊï¥ */
    padding-bottom: 0;
  }

  /* üì± ÁßªÂä®Á´ØÊ∂àÊÅØÂàóË°®‰ºòÂåñ */
  .messages-container :deep(.discord-message-list) {
    height: 100%;
    overflow-y: auto;
    overflow-x: hidden;
    /* üì± Âπ≥ÊªëÊªöÂä® */
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
  }

  /* üì± ÁßªÂä®Á´ØÊ∂àÊÅØÈ°πÁõÆ‰ºòÂåñ */
  .messages-container :deep(.message-item) {
    padding: 12px 16px;
    /* üì± Ëß¶Êë∏ÂèãÂ•Ω */
    touch-action: manipulation;
  }

  .messages-container :deep(.message-content) {
    /* üì± ÁßªÂä®Á´ØÊ∂àÊÅØÂÜÖÂÆπ‰ºòÂåñ */
    word-break: break-word;
    overflow-wrap: break-word;
  }

  /* üì± ÁßªÂä®Á´ØÂä†ËΩΩÁä∂ÊÄÅ */
  .messages-loading {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px 20px;
    text-align: center;
  }

  .loading-spinner {
    width: 32px;
    height: 32px;
    margin-bottom: 16px;
  }

  .loading-text {
    font-size: 14px;
    color: #6b7280;
  }

  /* üì± ÁßªÂä®Á´ØËæìÂÖ•ÂÆπÂô® */
  .input-container {
    /* üì± Âõ∫ÂÆöÂ∫ïÈÉ®ËæìÂÖ• */
    position: sticky;
    bottom: 0;
    background: white;
    border-top: 1px solid #e5e7eb;
    padding: 12px 16px;
    /* üì± Á°Æ‰øùËæìÂÖ•Âå∫Âüü‰∏çË¢´ÈîÆÁõòÈÅÆÊå° */
    z-index: 10;
  }

  .input-container :deep(.message-input) {
    width: 100%;
    /* üì± ÁßªÂä®Á´ØËæìÂÖ•Ê°Ü‰ºòÂåñ */
    min-height: 44px;
  }

  .input-container :deep(.input-field) {
    /* üì± ÁßªÂä®Á´ØËæìÂÖ•Â≠óÊÆµ */
    font-size: 16px; /* Èò≤Ê≠¢iOSÁº©Êîæ */
    padding: 12px 16px;
    border-radius: 24px;
  }

  .loading-input {
    padding: 16px;
    text-align: center;
    color: #6b7280;
    font-size: 14px;
  }

  /* üì± ÁßªÂä®Á´ØÊ®°ÊÄÅÊ°Ü‰ºòÂåñ */
  .chat-modal-overlay {
    /* üì± ÂÖ®Â±èÈÅÆÁΩ© */
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    /* üì± Èò≤Ê≠¢ËÉåÊôØÊªöÂä® */
    overflow: hidden;
  }

  .chat-modal {
    /* üì± ÁßªÂä®Á´ØÊ®°ÊÄÅÊ°Ü */
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: white;
    border-radius: 16px 16px 0 0;
    max-height: 90vh;
    overflow: hidden;
    /* üì± ÊªëÂÖ•Âä®Áîª */
    animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .chat-modal-large {
    /* üì± Â§ßÂûãÊ®°ÊÄÅÊ°Ü */
    max-height: 95vh;
  }

  @keyframes slideUp {
    from {
      transform: translateY(100%);
    }
    to {
      transform: translateY(0);
    }
  }

  .chat-modal-header {
    padding: 16px 20px;
    border-bottom: 1px solid var(--color-border);
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .chat-modal-header h3 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
  }

  .chat-modal-close {
    width: 32px;
    height: 32px;
    border: none;
    background: var(--color-background-soft);
    border-radius: 50%;
    font-size: 18px;
    color: var(--color-text-muted);
    cursor: pointer;
    /* üì± Ëß¶Êë∏ÂèãÂ•Ω */
    min-width: 44px;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: manipulation;
  }

  .chat-modal-content {
    padding: 20px;
    overflow-y: auto;
    max-height: calc(90vh - 80px);
    /* üì± Âπ≥ÊªëÊªöÂä® */
    -webkit-overflow-scrolling: touch;
  }

  /* üì± ÁßªÂä®Á´ØÊêúÁ¥¢Ê®°ÊÄÅÊ°Ü */
  .chat-modal-overlay :deep(.perfect-search-modal) {
    /* üì± ÊêúÁ¥¢Ê®°ÊÄÅÊ°ÜÂÖ®Â±è */
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 0;
    max-height: 100vh;
  }

  /* üì± ÁßªÂä®Á´ØÁøªËØëÈù¢Êùø */
  .chat-content-container :deep(.translation-panel) {
    /* üì± ÁøªËØëÈù¢ÊùøÂ∫ïÈÉ®Âõ∫ÂÆö */
    position: fixed;
    bottom: 80px;
    left: 16px;
    right: 16px;
    border-radius: 12px;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  }

  /* üì± ÁßªÂä®Á´ØÁî®Êà∑ËµÑÊñôÊ®°ÊÄÅÊ°Ü */
  .chat-content-container :deep(.user-profile-modal) {
    /* üì± Áî®Êà∑ËµÑÊñôÂÖ®Â±è */
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 0;
    max-height: 100vh;
  }
}

/* üì± ÁßªÂä®Á´ØÊ®™Â±èÈÄÇÈÖç */
@media (max-width: 768px) and (orientation: landscape) {
  .chat-header {
    height: 48px;
    min-height: 48px;
  }

  .chat-title h1 {
    font-size: 14px;
  }

  .chat-description {
    font-size: 11px;
  }

  .input-container {
    padding: 8px 16px;
  }

  .chat-modal {
    max-height: 85vh;
  }
}

/* üì± ÁßªÂä®Á´ØË∂ÖÂ∞èÂ±èÂπïÈÄÇÈÖç */
@media (max-width: 480px) {
  .chat-header {
    padding: 0 12px;
  }

  .header-action {
    width: 36px;
    height: 36px;
    min-width: 40px;
    min-height: 40px;
  }

  /* üì± Ë∂ÖÂ∞èÂ±èÂπïÊêúÁ¥¢ÊåâÈíÆ‰ºòÂåñ */
  .elegant-search {
    min-width: 42px !important;
    min-height: 42px !important;
    padding: 9px !important;
    border-radius: 10px !important;
  }

  .elegant-search .golden-search-icon {
    width: 20px !important;
    height: 20px !important;
  }

  .elegant-btn {
    min-width: 42px !important;
    min-height: 42px !important;
    padding: 9px !important;
    border-radius: 10px !important;
  }

  .elegant-btn .action-icon {
    width: 18px !important;
    height: 18px !important;
  }

  .chat-header-actions {
    gap: 4px;
  }

  .input-container {
    padding: 10px 12px;
  }

  .messages-container :deep(.message-item) {
    padding: 10px 12px;
  }

  .chat-modal-content {
    padding: 16px;
  }
}

/* üì± ÁßªÂä®Á´ØÈîÆÁõòÈÄÇÈÖç */
@media (max-width: 768px) {
  /* üì± iOS Safari viewport fix */
  .chat-content-container {
    height: 100%;
    /* üîß FIX: ‰ΩøÁî®CSSÂèòÈáèÂä®ÊÄÅÈÄÇÈÖç */
    height: var(--viewport-height, 100vh);
    height: -webkit-fill-available;
    /* üì± ÈîÆÁõòÈÄÇÈÖçÔºöÁ°Æ‰øùÂÆπÂô®ÂèØ‰ª•Âä®ÊÄÅË∞ÉÊï¥ */
    transition: height 0.3s ease;
    overflow: hidden;
  }

  /* üì± ÈîÆÁõòÊòæÁ§∫Êó∂ÁöÑÁâπÊÆäÈÄÇÈÖç */
  .chat-content-container.keyboard-visible {
    /* üîß FIX: ‰ΩøÁî®CSSÂèòÈáèËÄå‰∏çÊòØÁõ¥Êé•ËÆæÁΩÆÈ´òÂ∫¶ */
    height: var(--viewport-height, 100vh) !important;
    /* üì± ÈîÆÁõòÊòæÁ§∫Êó∂Á¶ÅÁî®ËøáÊ∏°Âä®ÁîªÔºåÈÅøÂÖçÈó™ÁÉÅ */
    transition: none;
    /* üì± Á°Æ‰øùÂÆπÂô®‰∏ç‰ºöË∂ÖÂá∫ËßÜÂè£ */
    max-height: var(--viewport-height, 100vh);
  }
  
  /* üîß FIX: Ê∑ªÂä†Ê∂àÊÅØÂÆπÂô®ÁöÑÂä®ÊÄÅÈ´òÂ∫¶ËÆ°ÁÆó */
  .chat-content-container.keyboard-visible .messages-container {
    height: calc(var(--viewport-height, 100vh) - 56px - 80px);
    /* 56px = header, 80px = input */
  }
  
  /* üîß FIX: ËæìÂÖ•ÂÆπÂô®Âõ∫ÂÆöÂú®Â∫ïÈÉ® */
  .chat-content-container.keyboard-visible .input-container {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: var(--color-background);
    border-top: 1px solid var(--color-border);
    z-index: 100;
  }

  /* üì± ÈîÆÁõòÂºπÂá∫Êó∂ÁöÑÊ∂àÊÅØÂÆπÂô®ÈÄÇÈÖç */
  .keyboard-visible .messages-container {
    /* üì± ÈîÆÁõòÊòæÁ§∫Êó∂Á°Æ‰øùÊ∂àÊÅØÂå∫ÂüüÂèØÊªöÂä® */
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    /* üì± Âπ≥ÊªëËøáÊ∏° */
    transition: height 0.3s ease;
  }

  /* üì± ÈîÆÁõòÂºπÂá∫Êó∂ÁöÑËæìÂÖ•ÂÆπÂô®ÈÄÇÈÖç */
  .keyboard-visible .input-container {
    /* üì± Á°Æ‰øùËæìÂÖ•Ê°ÜÂßãÁªàÂèØËßÅ */
    position: sticky !important;
    bottom: 0 !important;
    z-index: 100 !important;
    background: var(--color-background) !important;
    border-top: 1px solid var(--color-border) !important;
    /* üì± Èò≤Ê≠¢ËæìÂÖ•Ê°ÜË¢´ÈîÆÁõòÈÅÆÊå° */
    margin-bottom: env(keyboard-inset-height, 0px);
    /* üì± iOSÂÆâÂÖ®Âå∫ÂüüÈÄÇÈÖç */
    padding-bottom: env(safe-area-inset-bottom, 0px);
  }

  /* üì± ËæìÂÖ•Ê°ÜËÅöÁÑ¶Êó∂ÁöÑÈ¢ùÂ§ñÈÄÇÈÖç */
  .input-container :deep(.message-textarea:focus) {
    /* üì± Èò≤Ê≠¢iOSÁº©Êîæ */
    font-size: 16px !important;
    /* üì± Á°Æ‰øùËæìÂÖ•Ê°ÜÂèØËßÅ */
    transform: translateZ(0);
    /* üì± Á°¨‰ª∂Âä†ÈÄü */
    -webkit-transform: translateZ(0);
  }

  /* üì± ÈîÆÁõòÂºπÂá∫Êó∂ÁöÑÊ∂àÊÅØÈ°πÁõÆ‰ºòÂåñ */
  .keyboard-visible .messages-container :deep(.message-item) {
    /* üì± ÂáèÂ∞ëÂÜÖËæπË∑ùÔºåËäÇÁúÅÁ©∫Èó¥ */
    padding: 8px 12px;
  }

  /* üì± ÈîÆÁõòÂºπÂá∫Êó∂ÁöÑÂ§¥ÈÉ®ÈÄÇÈÖç */
  .keyboard-visible .chat-header {
    /* üì± Á°Æ‰øùÂ§¥ÈÉ®‰∏çË¢´ÈÅÆÊå° */
    position: sticky;
    top: 0;
    z-index: 10;
    /* üì± ÂáèÂ∞èÂ§¥ÈÉ®È´òÂ∫¶ÔºåËäÇÁúÅÁ©∫Èó¥ */
    height: 48px;
    min-height: 48px;
    padding: 0 12px;
  }

  .keyboard-visible .chat-header .chat-title h1 {
    font-size: 14px;
  }

  .keyboard-visible .chat-header .chat-description {
    font-size: 11px;
  }

  /* üì± ÈîÆÁõòÁéØÂ¢É‰∏ãÁöÑÊêúÁ¥¢ÊåâÈíÆ‰ºòÂåñ */
  .keyboard-visible .chat-header-actions {
    gap: 4px;
  }

  .keyboard-visible .elegant-search {
    /* üì± ÈîÆÁõòÊòæÁ§∫Êó∂ÂéãÁº©ÊêúÁ¥¢ÊåâÈíÆ */
    min-width: 40px !important;
    min-height: 40px !important;
    padding: 8px !important;
    border-radius: 10px !important;
  }

  .keyboard-visible .elegant-search .golden-search-icon {
    width: 18px !important;
    height: 18px !important;
  }

  .keyboard-visible .elegant-btn {
    /* üì± ÈîÆÁõòÊòæÁ§∫Êó∂ÂéãÁº©ËÆæÁΩÆÊåâÈíÆ */
    min-width: 40px !important;
    min-height: 40px !important;
    padding: 8px !important;
    border-radius: 10px !important;
  }

  .keyboard-visible .elegant-btn .action-icon {
    width: 18px !important;
    height: 18px !important;
  }

  /* üì± ÈîÆÁõòÁéØÂ¢É‰∏ãSidebarÊåâÈíÆ‰ºòÂåñ */
  .keyboard-visible .mobile-sidebar-btn {
    min-width: 40px !important;
    min-height: 40px !important;
    margin-right: 8px !important;
  }

  /* üì± ÈîÆÁõòÁéØÂ¢É‰∏ãÁöÑÊ®°ÊÄÅÊ°ÜÈÄÇÈÖç */
  .keyboard-visible .chat-modal-overlay {
    /* üì± ÈîÆÁõòÊòæÁ§∫Êó∂Ê®°ÊÄÅÊ°Ü‰πüË¶ÅÈÄÇÈÖç */
    height: 100vh;
    height: -webkit-fill-available;
  }

  /* üì± Visual Viewport APIÊîØÊåÅ */
  @supports (height: 100dvh) {
    .chat-content-container {
      height: 100dvh;
    }
    
    .keyboard-visible {
      height: 100dvh;
    }
  }

  /* üì± ÈîÆÁõòÊî∂Ëµ∑Êó∂ÁöÑÂπ≥ÊªëËøáÊ∏° */
  .chat-content-container:not(.keyboard-visible) {
    transition: height 0.3s ease;
  }

  .chat-content-container:not(.keyboard-visible) .messages-container {
    transition: height 0.3s ease;
  }

  .chat-content-container:not(.keyboard-visible) .input-container {
    transition: all 0.3s ease;
  }
}

/* üì± ÁâπÊÆäÁöÑiOSÈîÆÁõòÈÄÇÈÖç */
@supports (-webkit-touch-callout: none) {
  @media (max-width: 768px) {
    .keyboard-visible .input-container {
      /* üì± iOSÁâπÊÆäÂ§ÑÁêÜÔºö‰ΩøÁî®transformËÄå‰∏çÊòØposition */
      transform: translateY(0);
      -webkit-transform: translateY(0);
    }
    
    .keyboard-visible .messages-container {
      /* üì± iOSÁâπÊÆäÂ§ÑÁêÜÔºöÁ°Æ‰øùÊ∂àÊÅØÂå∫Âüü‰∏çË¢´ÈîÆÁõòÈÅÆÊå° */
      padding-bottom: 0 !important;
      margin-bottom: 0 !important;
    }
  }
}

/* üì± AndroidÈîÆÁõòÈÄÇÈÖç */
@media (max-width: 768px) and (not (-webkit-touch-callout: none)) {
  .keyboard-visible .input-container {
    /* üì± AndroidÁâπÊÆäÂ§ÑÁêÜ */
    position: fixed !important;
    bottom: 0 !important;
    left: 0 !important;
    right: 0 !important;
    width: 100% !important;
  }
}

/* üì± ÈîÆÁõòÂºπÂá∫Âä®Áîª‰ºòÂåñ */
@media (max-width: 768px) and (prefers-reduced-motion: no-preference) {
  .chat-content-container {
    transition: height 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .messages-container {
    transition: height 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  }
  
  .input-container {
    transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
  }
}

/* üì± ÂáèÂ∞ëÂä®ÁîªÁöÑÁî®Êà∑ÂÅèÂ•ΩÈÄÇÈÖç */
@media (max-width: 768px) and (prefers-reduced-motion: reduce) {
  .chat-content-container,
  .messages-container,
  .input-container {
    transition: none !important;
  }
}

/* üì± ÁßªÂä®Á´ØSidebarÊåâÈíÆ */
.mobile-sidebar-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 44px;
  height: 44px;
  border: none;
  background: var(--color-primary-alpha);
  color: var(--color-primary);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-right: 12px;
  /* üö® Á°Æ‰øùË∂≥Â§üÁöÑËß¶Êë∏ÁõÆÊ†á */
  min-width: 44px;
  min-height: 44px;
  touch-action: manipulation;
}

.mobile-sidebar-btn:hover {
  background: var(--color-primary-light);
  transform: scale(1.05);
}

.mobile-sidebar-btn:active {
  transform: scale(0.95);
  background: var(--color-primary-dark);
}

.mobile-sidebar-btn svg {
  width: 20px;
  height: 20px;
  stroke-width: 2;
}

/* üì± È´òÂØπÊØîÂ∫¶Ê®°ÂºèÊêúÁ¥¢ÊåâÈíÆÈÄÇÈÖç */
@media (prefers-contrast: high) {
  .elegant-search {
    background: var(--color-primary-light) !important;
    border: 2px solid var(--color-primary) !important;
    color: var(--color-primary-dark) !important;
  }

  .elegant-search:hover,
  .elegant-search:active {
    background: var(--color-primary-dark) !important;
    border-color: var(--color-primary-darker) !important;
  }

  .elegant-search .golden-search-icon {
    stroke-width: 3 !important;
    color: var(--color-primary-dark) !important;
  }

  .elegant-btn {
    background: var(--color-background-muted) !important;
    border: 2px solid var(--color-border) !important;
    color: var(--color-text-muted) !important;
  }

  .elegant-btn:hover,
  .elegant-btn:active {
    background: var(--color-background-soft) !important;
    border-color: var(--color-border-hover) !important;
  }
}

/* üì± Êó†ÈöúÁ¢çÈÄÇÈÖçÔºöÂáèÂ∞ëÂä®ÁîªÂÅèÂ•Ω */
@media (prefers-reduced-motion: reduce) {
  .elegant-search,
  .elegant-btn {
    transition: none !important;
  }

  .elegant-search:hover,
  .elegant-search:active,
  .elegant-btn:hover,
  .elegant-btn:active {
    transform: none !important;
  }
}

/* üì± Ëß¶Êë∏ËÆæÂ§á‰ºòÂåñ */
@media (pointer: coarse) {
  .elegant-search,
  .elegant-btn {
    /* üì± Â¢ûÂ§ßËß¶Êë∏ÁõÆÊ†á */
    min-width: 48px !important;
    min-height: 48px !important;
  }

  .elegant-search:hover,
  .elegant-btn:hover {
    /* üì± Ëß¶Êë∏ËÆæÂ§á‰∏çÈúÄË¶ÅhoverÊïàÊûú */
    transform: none !important;
  }

  .elegant-search:active,
  .elegant-btn:active {
    /* üì± Ëß¶Êë∏ÂèçÈ¶à */
    transform: scale(0.96) !important;
    transition: transform 0.1s ease !important;
  }
}
</style>