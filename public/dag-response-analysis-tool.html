<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DAG Response Analysis Tool</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
    }

    .container {
      background: white;
      border-radius: 15px;
      padding: 30px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    }

    h1 {
      text-align: center;
      color: #2d3748;
      margin-bottom: 10px;
    }

    .subtitle {
      text-align: center;
      color: #718096;
      margin-bottom: 30px;
      font-style: italic;
    }

    .error-chain {
      background: #fed7d7;
      border: 2px solid #fc8181;
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
    }

    .error-step {
      display: flex;
      align-items: center;
      margin: 10px 0;
      padding: 12px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #e53e3e;
    }

    .step-number {
      background: #e53e3e;
      color: white;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      margin-right: 15px;
      flex-shrink: 0;
    }

    .step-content {
      flex: 1;
    }

    .step-title {
      font-weight: bold;
      color: #742a2a;
      margin-bottom: 5px;
    }

    .step-details {
      color: #4a5568;
      font-size: 14px;
    }

    .analysis-section {
      background: #f8fafc;
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
      border-left: 4px solid #3182ce;
    }

    .test-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }

    .test-card {
      background: white;
      border-radius: 8px;
      padding: 20px;
      border: 1px solid #e2e8f0;
      transition: all 0.3s ease;
    }

    .test-card:hover {
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .test-card h4 {
      margin-top: 0;
      color: #2d3748;
      display: flex;
      align-items: center;
    }

    .test-card h4::before {
      font-size: 20px;
      margin-right: 10px;
    }

    .request-test h4::before {
      content: "ğŸ“¡";
    }

    .response-test h4::before {
      content: "ğŸ“¥";
    }

    .parse-test h4::before {
      content: "ğŸ”¬";
    }

    .format-test h4::before {
      content: "ğŸ“‹";
    }

    .button {
      background: linear-gradient(135deg, #3182ce 0%, #2b6cb0 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin: 5px;
      width: 100%;
    }

    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .button.secondary {
      background: linear-gradient(135deg, #718096 0%, #4a5568 100%);
    }

    .results {
      margin-top: 15px;
      padding: 15px;
      border-radius: 8px;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      max-height: 400px;
      overflow-y: auto;
      display: none;
    }

    .info {
      background: #ebf8ff;
      color: #2a4365;
      border: 1px solid #90cdf4;
    }

    .success {
      background: #f0fff4;
      color: #22543d;
      border: 1px solid #9ae6b4;
    }

    .error {
      background: #fed7d7;
      color: #742a2a;
      border: 1px solid #fc8181;
    }

    .warning {
      background: #fffaf0;
      color: #744210;
      border: 1px solid #f6ad55;
    }

    .response-viewer {
      background: #f7fafc;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      padding: 15px;
      margin: 15px 0;
      max-height: 300px;
      overflow-y: auto;
    }

    .response-header {
      font-weight: bold;
      color: #2d3748;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #e2e8f0;
    }

    .json-viewer {
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #2d3748;
      white-space: pre-wrap;
    }

    .fix-recommendations {
      background: #f0fff4;
      border: 2px solid #68d391;
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
    }

    .fix-item {
      display: flex;
      align-items: flex-start;
      margin: 15px 0;
      padding: 15px;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #38a169;
    }

    .fix-icon {
      font-size: 24px;
      margin-right: 15px;
      flex-shrink: 0;
    }

    .fix-content {
      flex: 1;
    }

    .fix-title {
      font-weight: bold;
      color: #2d3748;
      margin-bottom: 8px;
    }

    .fix-description {
      color: #4a5568;
      margin-bottom: 10px;
    }

    .fix-code {
      background: #f7fafc;
      border: 1px solid #e2e8f0;
      border-radius: 6px;
      padding: 12px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      color: #2d3748;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-success {
      background: #38a169;
    }

    .status-error {
      background: #e53e3e;
    }

    .status-warning {
      background: #dd6b20;
    }

    .status-info {
      background: #3182ce;
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }

    .comparison-table th,
    .comparison-table td {
      border: 1px solid #e2e8f0;
      padding: 12px;
      text-align: left;
    }

    .comparison-table th {
      background: #f7fafc;
      font-weight: bold;
      color: #2d3748;
    }

    .file-drop-zone {
      border: 2px dashed #cbd5e0;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      margin: 15px 0;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .file-drop-zone:hover {
      border-color: #3182ce;
      background: #f7fafc;
    }

    .file-drop-zone.dragover {
      border-color: #3182ce;
      background: #ebf8ff;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>ğŸ”¬ DAGå“åº”è§£æåˆ†æå·¥å…·</h1>
    <p class="subtitle">æ·±åº¦åˆ†æPOST /files/singleå“åº”è§£æå¤±è´¥çš„æ ¹å› </p>

    <!-- é”™è¯¯è°ƒç”¨é“¾é‡æ„ -->
    <div class="error-chain">
      <h3>âŒ ç¡®è®¤çš„é”™è¯¯è°ƒç”¨é“¾</h3>
      <div class="error-step">
        <div class="step-number">1</div>
        <div class="step-content">
          <div class="step-title">MessageInput.vue:931 â†’ sendMessage()</div>
          <div class="step-details">ç”¨æˆ·è§¦å‘æ¶ˆæ¯å‘é€ï¼ŒåŒ…å«æ–‡ä»¶ä¸Šä¼ </div>
        </div>
      </div>

      <div class="error-step">
        <div class="step-number">2</div>
        <div class="step-content">
          <div class="step-title">fileUploadStore.js:426 â†’ uploadAll()</div>
          <div class="step-details">æ–‡ä»¶ä¸Šä¼ å­˜å‚¨ç®¡ç†å™¨ï¼Œä½¿ç”¨Promise.allSettledå¹¶å‘å¤„ç†</div>
        </div>
      </div>

      <div class="error-step">
        <div class="step-number">3</div>
        <div class="step-content">
          <div class="step-title">fileUploadStore.js:368 â†’ ChatService.uploadFile()</div>
          <div class="step-details">è°ƒç”¨ChatServiceè¿›è¡Œå®é™…æ–‡ä»¶ä¸Šä¼ </div>
        </div>
      </div>

      <div class="error-step">
        <div class="step-number">4</div>
        <div class="step-content">
          <div class="step-title">ChatService.ts:722 â†’ throw new Error("File upload failed")</div>
          <div class="step-details">âŒ æ•…éšœç‚¹ï¼šå“åº”è§£æå¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯</div>
        </div>
      </div>

      <div class="error-step">
        <div class="step-number">5</div>
        <div class="step-content">
          <div class="step-title">æœ€ç»ˆé”™è¯¯ï¼šNetwork error. Please check your connection.</div>
          <div class="step-details">handleError()å°†å“åº”é”™è¯¯è½¬æ¢ä¸ºç½‘ç»œé”™è¯¯</div>
        </div>
      </div>
    </div>

    <!-- ç»†ç²’åº¦æµ‹è¯•ç½‘æ ¼ -->
    <div class="test-grid">
      <div class="test-card request-test">
        <h4>è¯·æ±‚å‘é€æµ‹è¯•</h4>
        <p>æµ‹è¯•POST /files/singleè¯·æ±‚æ˜¯å¦èƒ½æ­£ç¡®å‘é€</p>
        <button class="button" onclick="testRequestSending()">ğŸš€ æµ‹è¯•è¯·æ±‚å‘é€</button>
        <div id="request-results" class="results"></div>
      </div>

      <div class="test-card response-test">
        <h4>å“åº”æ¥æ”¶æµ‹è¯•</h4>
        <p>æµ‹è¯•æœåŠ¡å™¨å“åº”çš„å®Œæ•´æ€§å’Œæ ¼å¼</p>
        <button class="button" onclick="testResponseReceiving()">ğŸ“¥ æµ‹è¯•å“åº”æ¥æ”¶</button>
        <div id="response-results" class="results"></div>
      </div>

      <div class="test-card parse-test">
        <h4>å“åº”è§£ææµ‹è¯•</h4>
        <p>æµ‹è¯•response.data.successå’Œresponse.data.dataçš„è§£æ</p>
        <button class="button" onclick="testResponseParsing()">ğŸ”¬ æµ‹è¯•å“åº”è§£æ</button>
        <div id="parse-results" class="results"></div>
      </div>

      <div class="test-card format-test">
        <h4>æ•°æ®æ ¼å¼æ¯”å¯¹</h4>
        <p>æ¯”å¯¹å‰ç«¯æœŸæœ›æ ¼å¼ä¸åç«¯å®é™…è¿”å›æ ¼å¼</p>
        <button class="button" onclick="testFormatComparison()">ğŸ“‹ æ¯”å¯¹æ•°æ®æ ¼å¼</button>
        <div id="format-results" class="results"></div>
      </div>
    </div>

    <!-- å®é™…æ–‡ä»¶ä¸Šä¼ æµ‹è¯• -->
    <div class="analysis-section">
      <h3>ğŸ“ å®é™…æ–‡ä»¶ä¸Šä¼ æµ‹è¯•</h3>
      <div class="file-drop-zone" id="file-drop-zone" onclick="document.getElementById('file-input').click()">
        <input type="file" id="file-input" style="display: none;" onchange="handleFileUpload(event)">
        ğŸ“ ç‚¹å‡»é€‰æ‹©æ–‡ä»¶æˆ–æ‹–æ‹½åˆ°æ­¤å¤„
        <br><small>å°†æ‰§è¡Œå®Œæ•´çš„ä¸Šä¼ æµç¨‹å¹¶åˆ†ææ¯ä¸ªæ­¥éª¤</small>
      </div>
      <button class="button secondary" onclick="runFullUploadAnalysis()">ğŸ” æ‰§è¡Œå®Œæ•´ä¸Šä¼ åˆ†æ</button>
      <div id="upload-analysis-results" class="results info" style="display: none;"></div>
    </div>

    <!-- å“åº”æŸ¥çœ‹å™¨ -->
    <div class="analysis-section" id="response-viewer-section" style="display: none;">
      <h3>ğŸ“Š å“åº”æ•°æ®æŸ¥çœ‹å™¨</h3>
      <div class="response-viewer">
        <div class="response-header">åŸå§‹å“åº”æ•°æ®</div>
        <div id="raw-response" class="json-viewer"></div>
      </div>
      <div class="response-viewer">
        <div class="response-header">è§£æåæ•°æ®ç»“æ„</div>
        <div id="parsed-response" class="json-viewer"></div>
      </div>
    </div>

    <!-- ä¿®å¤å»ºè®® -->
    <div class="fix-recommendations" id="fix-recommendations" style="display: none;">
      <h3>ğŸ› ï¸ æ™ºèƒ½ä¿®å¤å»ºè®®</h3>
      <div id="fix-items"></div>
    </div>
  </div>

  <script>
    let selectedFile = null;
    let lastResponse = null;

    // å·¥å…·å‡½æ•°
    function logMessage(containerId, message, type = 'info') {
      const container = document.getElementById(containerId);
      container.style.display = 'block';
      container.className = `results ${type}`;
      container.textContent += `[${new Date().toLocaleTimeString()}] ${message}\n`;
      container.scrollTop = container.scrollHeight;
    }

    function clearResults(containerId) {
      const container = document.getElementById(containerId);
      container.textContent = '';
      container.style.display = 'none';
    }

    function showResponseViewer(response, parsedData) {
      const section = document.getElementById('response-viewer-section');
      const rawDiv = document.getElementById('raw-response');
      const parsedDiv = document.getElementById('parsed-response');

      section.style.display = 'block';
      rawDiv.textContent = JSON.stringify(response, null, 2);
      parsedDiv.textContent = JSON.stringify(parsedData, null, 2);
    }

    // è¯·æ±‚å‘é€æµ‹è¯•
    async function testRequestSending() {
      clearResults('request-results');
      logMessage('request-results', 'ğŸš€ æµ‹è¯•POST /files/singleè¯·æ±‚å‘é€...', 'info');

      try {
        // åˆ›å»ºæœ€å°æµ‹è¯•æ–‡ä»¶
        const testFile = new File(['test'], 'test.txt', { type: 'text/plain' });
        const formData = new FormData();
        formData.append('file', testFile);

        logMessage('request-results', 'ğŸ“Š è¯·æ±‚é…ç½®:', 'info');
        logMessage('request-results', `   æ–¹æ³•: POST`, 'info');
        logMessage('request-results', `   ç«¯ç‚¹: /api/files/single`, 'info');
        logMessage('request-results', `   å†…å®¹: FormData with file`, 'info');
        logMessage('request-results', `   æ–‡ä»¶: ${testFile.name} (${testFile.size} bytes)`, 'info');

        const authToken = localStorage.getItem('auth_token');
        const headers = {};
        if (authToken) {
          headers['Authorization'] = `Bearer ${authToken}`;
          logMessage('request-results', `   è®¤è¯: Bearer token present`, 'info');
        } else {
          logMessage('request-results', `   âš ï¸ è®¤è¯: No auth token found`, 'warning');
        }

        logMessage('request-results', '\nğŸŒ å‘é€è¯·æ±‚...', 'info');

        const startTime = Date.now();
        const response = await fetch('/api/files/single', {
          method: 'POST',
          body: formData,
          headers: headers
        });
        const responseTime = Date.now() - startTime;

        logMessage('request-results', `âœ… è¯·æ±‚å‘é€æˆåŠŸ`, 'success');
        logMessage('request-results', `ğŸ“Š å“åº”æ—¶é—´: ${responseTime}ms`, 'success');
        logMessage('request-results', `ğŸ“Š çŠ¶æ€ç : ${response.status}`, response.ok ? 'success' : 'error');
        logMessage('request-results', `ğŸ“Š çŠ¶æ€æ–‡æœ¬: ${response.statusText}`, response.ok ? 'success' : 'error');

        // æ£€æŸ¥å“åº”å¤´
        logMessage('request-results', '\nğŸ“‹ å“åº”å¤´ä¿¡æ¯:', 'info');
        response.headers.forEach((value, key) => {
          logMessage('request-results', `   ${key}: ${value}`, 'info');
        });

        lastResponse = response.clone();

        if (response.ok) {
          logMessage('request-results', '\nâœ… è¯·æ±‚å‘é€å±‚é¢ï¼šæ­£å¸¸', 'success');
        } else {
          logMessage('request-results', '\nâŒ è¯·æ±‚å‘é€å±‚é¢ï¼šå¤±è´¥', 'error');
        }

      } catch (error) {
        logMessage('request-results', `âŒ è¯·æ±‚å‘é€å¤±è´¥: ${error.message}`, 'error');
        logMessage('request-results', `ğŸ“Š é”™è¯¯ç±»å‹: ${error.name}`, 'error');
        logMessage('request-results', `ğŸ“Š ç½‘ç»œé”™è¯¯: ${!error.response}`, 'error');
      }
    }

    // å“åº”æ¥æ”¶æµ‹è¯•
    async function testResponseReceiving() {
      clearResults('response-results');
      logMessage('response-results', 'ğŸ“¥ æµ‹è¯•å“åº”æ¥æ”¶å®Œæ•´æ€§...', 'info');

      try {
        const testFile = new File(['test'], 'test.txt', { type: 'text/plain' });
        const formData = new FormData();
        formData.append('file', testFile);

        const authToken = localStorage.getItem('auth_token');
        const headers = {};
        if (authToken) {
          headers['Authorization'] = `Bearer ${authToken}`;
        }

        const response = await fetch('/api/files/single', {
          method: 'POST',
          body: formData,
          headers: headers
        });

        logMessage('response-results', `ğŸ“Š å“åº”çŠ¶æ€: ${response.status} ${response.statusText}`, 'info');
        logMessage('response-results', `ğŸ“Š å“åº”ç±»å‹: ${response.headers.get('content-type')}`, 'info');
        logMessage('response-results', `ğŸ“Š å“åº”å¤§å°: ${response.headers.get('content-length') || 'unknown'}`, 'info');

        // å°è¯•è¯»å–å“åº”ä½“
        logMessage('response-results', '\nğŸ“– è¯»å–å“åº”ä½“...', 'info');

        try {
          const clonedResponse = response.clone();
          const textContent = await clonedResponse.text();

          logMessage('response-results', `âœ… å“åº”ä½“è¯»å–æˆåŠŸ`, 'success');
          logMessage('response-results', `ğŸ“Š å“åº”é•¿åº¦: ${textContent.length} å­—ç¬¦`, 'success');
          logMessage('response-results', `ğŸ“Š å“åº”é¢„è§ˆ: ${textContent.substring(0, 200)}...`, 'info');

          // å°è¯•JSONè§£æ
          try {
            const jsonData = JSON.parse(textContent);
            logMessage('response-results', `âœ… JSONè§£ææˆåŠŸ`, 'success');
            logMessage('response-results', `ğŸ“Š JSONç»“æ„: ${JSON.stringify(jsonData, null, 2)}`, 'success');

            showResponseViewer(jsonData, jsonData);

          } catch (jsonError) {
            logMessage('response-results', `âŒ JSONè§£æå¤±è´¥: ${jsonError.message}`, 'error');
            logMessage('response-results', `ğŸ“Š åŸå§‹å†…å®¹: ${textContent}`, 'error');
          }

        } catch (readError) {
          logMessage('response-results', `âŒ å“åº”ä½“è¯»å–å¤±è´¥: ${readError.message}`, 'error');
        }

      } catch (error) {
        logMessage('response-results', `âŒ å“åº”æ¥æ”¶æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // å“åº”è§£ææµ‹è¯•
    async function testResponseParsing() {
      clearResults('parse-results');
      logMessage('parse-results', 'ğŸ”¬ æµ‹è¯•ChatServiceå“åº”è§£æé€»è¾‘...', 'info');

      try {
        const testFile = new File(['test'], 'test.txt', { type: 'text/plain' });
        const formData = new FormData();
        formData.append('file', testFile);

        const authToken = localStorage.getItem('auth_token');
        const headers = {};
        if (authToken) {
          headers['Authorization'] = `Bearer ${authToken}`;
        }

        logMessage('parse-results', 'ğŸ“¡ æ‰§è¡Œå®é™…è¯·æ±‚...', 'info');

        // æ¨¡æ‹ŸChatServiceä¸­çš„axiosè°ƒç”¨
        const { default: api } = await import('../src/services/api.js');

        try {
          const response = await api.post('/files/single', formData, {
            headers: {
              'Content-Type': 'multipart/form-data',
            },
            timeout: 30000,
          });

          logMessage('parse-results', 'âœ… Axiosè¯·æ±‚æˆåŠŸ', 'success');
          logMessage('parse-results', `ğŸ“Š Responseå¯¹è±¡ç»“æ„:`, 'info');
          logMessage('parse-results', `   status: ${response.status}`, 'info');
          logMessage('parse-results', `   statusText: ${response.statusText}`, 'info');
          logMessage('parse-results', `   data: ${JSON.stringify(response.data, null, 2)}`, 'info');

          // æ¨¡æ‹ŸChatServiceçš„è§£æé€»è¾‘
          logMessage('parse-results', '\nğŸ” æ¨¡æ‹ŸChatServiceè§£æé€»è¾‘...', 'info');

          if (response.data.success && response.data.data) {
            const uploadData = response.data.data;
            logMessage('parse-results', 'âœ… è§£ææˆåŠŸ - æ•°æ®ç»“æ„æ­£ç¡®', 'success');
            logMessage('parse-results', `ğŸ“Š ä¸Šä¼ æ•°æ®: ${JSON.stringify(uploadData, null, 2)}`, 'success');

            // æ£€æŸ¥å¿…éœ€å­—æ®µ
            const requiredFields = ['id', 'filename', 'url', 'mime_type', 'size', 'created_at'];
            const missingFields = requiredFields.filter(field => !uploadData[field]);

            if (missingFields.length > 0) {
              logMessage('parse-results', `âš ï¸ ç¼ºå¤±å­—æ®µ: ${missingFields.join(', ')}`, 'warning');
            } else {
              logMessage('parse-results', 'âœ… æ‰€æœ‰å¿…éœ€å­—æ®µéƒ½å­˜åœ¨', 'success');
            }

          } else {
            logMessage('parse-results', 'âŒ è§£æå¤±è´¥ - å“åº”ç»“æ„ä¸ç¬¦åˆé¢„æœŸ', 'error');
            logMessage('parse-results', `ğŸ“Š response.data.success: ${response.data.success}`, 'error');
            logMessage('parse-results', `ğŸ“Š response.data.data: ${JSON.stringify(response.data.data)}`, 'error');

            if (response.data.error) {
              logMessage('parse-results', `ğŸ“Š errorä¿¡æ¯: ${JSON.stringify(response.data.error)}`, 'error');
            }
          }

        } catch (axiosError) {
          logMessage('parse-results', `âŒ Axiosè¯·æ±‚å¤±è´¥: ${axiosError.message}`, 'error');
          logMessage('parse-results', `ğŸ“Š é”™è¯¯çŠ¶æ€: ${axiosError.response?.status}`, 'error');
          logMessage('parse-results', `ğŸ“Š é”™è¯¯æ•°æ®: ${JSON.stringify(axiosError.response?.data)}`, 'error');
        }

      } catch (error) {
        logMessage('parse-results', `âŒ å“åº”è§£ææµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // æ•°æ®æ ¼å¼æ¯”å¯¹
    async function testFormatComparison() {
      clearResults('format-results');
      logMessage('format-results', 'ğŸ“‹ æ¯”å¯¹å‰ç«¯æœŸæœ›æ ¼å¼ä¸åç«¯è¿”å›æ ¼å¼...', 'info');

      // å‰ç«¯æœŸæœ›æ ¼å¼
      const expectedFormat = {
        success: true,
        data: {
          id: "number",
          filename: "string",
          url: "string",
          mime_type: "string",
          size: "number",
          created_at: "string"
        }
      };

      logMessage('format-results', 'ğŸ“Š å‰ç«¯æœŸæœ›æ ¼å¼:', 'info');
      logMessage('format-results', JSON.stringify(expectedFormat, null, 2), 'info');

      try {
        const testFile = new File(['test'], 'test.txt', { type: 'text/plain' });
        const formData = new FormData();
        formData.append('file', testFile);

        const authToken = localStorage.getItem('auth_token');
        const headers = {};
        if (authToken) {
          headers['Authorization'] = `Bearer ${authToken}`;
        }

        const response = await fetch('/api/files/single', {
          method: 'POST',
          body: formData,
          headers: headers
        });

        if (response.ok) {
          const actualData = await response.json();

          logMessage('format-results', '\nğŸ“Š åç«¯å®é™…è¿”å›æ ¼å¼:', 'info');
          logMessage('format-results', JSON.stringify(actualData, null, 2), 'info');

          // æ ¼å¼æ¯”å¯¹
          logMessage('format-results', '\nğŸ” æ ¼å¼æ¯”å¯¹ç»“æœ:', 'info');

          // æ£€æŸ¥é¡¶å±‚ç»“æ„
          const hasSuccess = 'success' in actualData;
          const hasData = 'data' in actualData;

          logMessage('format-results', `   successå­—æ®µ: ${hasSuccess ? 'âœ…' : 'âŒ'} ${actualData.success}`, hasSuccess ? 'success' : 'error');
          logMessage('format-results', `   dataå­—æ®µ: ${hasData ? 'âœ…' : 'âŒ'} ${typeof actualData.data}`, hasData ? 'success' : 'error');

          if (hasData && actualData.data) {
            const dataObj = actualData.data;
            const expectedFields = Object.keys(expectedFormat.data);

            logMessage('format-results', '\nğŸ“‹ å­—æ®µæ£€æŸ¥:', 'info');
            expectedFields.forEach(field => {
              const exists = field in dataObj;
              const type = typeof dataObj[field];
              const expectedType = expectedFormat.data[field];
              const typeMatch = type === expectedType;

              logMessage('format-results', `   ${field}: ${exists ? 'âœ…' : 'âŒ'} (${type} vs ${expectedType})`,
                exists && typeMatch ? 'success' : 'error');
            });
          }

          showResponseViewer(actualData, expectedFormat);

        } else {
          logMessage('format-results', `âŒ è¯·æ±‚å¤±è´¥: ${response.status}`, 'error');
          const errorText = await response.text();
          logMessage('format-results', `ğŸ“Š é”™è¯¯å†…å®¹: ${errorText}`, 'error');
        }

      } catch (error) {
        logMessage('format-results', `âŒ æ ¼å¼æ¯”å¯¹å¤±è´¥: ${error.message}`, 'error');
      }
    }

    // æ–‡ä»¶ä¸Šä¼ å¤„ç†
    function setupFileDropZone() {
      const dropZone = document.getElementById('file-drop-zone');

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, preventDefaults, false);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      ['dragenter', 'dragover'].forEach(eventName => {
        dropZone.addEventListener(eventName, () => dropZone.classList.add('dragover'), false);
      });

      ['dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, () => dropZone.classList.remove('dragover'), false);
      });

      dropZone.addEventListener('drop', function (e) {
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          selectedFile = files[0];
          handleFileUpload({ target: { files: [files[0]] } });
        }
      }, false);
    }

    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (file) {
        selectedFile = file;
        clearResults('upload-analysis-results');
        logMessage('upload-analysis-results', `ğŸ“ å·²é€‰æ‹©æ–‡ä»¶: ${file.name} (${file.size} bytes)`, 'info');
        logMessage('upload-analysis-results', 'ğŸ’¡ ç‚¹å‡»"æ‰§è¡Œå®Œæ•´ä¸Šä¼ åˆ†æ"å¼€å§‹è¯¦ç»†åˆ†æ', 'info');
      }
    }

    // å®Œæ•´ä¸Šä¼ åˆ†æ
    async function runFullUploadAnalysis() {
      if (!selectedFile) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
        return;
      }

      clearResults('upload-analysis-results');
      logMessage('upload-analysis-results', 'ğŸ” å¼€å§‹å®Œæ•´ä¸Šä¼ åˆ†ææµç¨‹...', 'info');

      try {
        const formData = new FormData();
        formData.append('file', selectedFile);

        const authToken = localStorage.getItem('auth_token');
        const headers = {};
        if (authToken) {
          headers['Authorization'] = `Bearer ${authToken}`;
        }

        logMessage('upload-analysis-results', '\n1ï¸âƒ£ å‡†å¤‡é˜¶æ®µ', 'info');
        logMessage('upload-analysis-results', `   æ–‡ä»¶: ${selectedFile.name}`, 'info');
        logMessage('upload-analysis-results', `   å¤§å°: ${selectedFile.size} bytes`, 'info');
        logMessage('upload-analysis-results', `   ç±»å‹: ${selectedFile.type}`, 'info');
        logMessage('upload-analysis-results', `   è®¤è¯: ${authToken ? 'å·²é…ç½®' : 'æœªé…ç½®'}`, authToken ? 'success' : 'warning');

        logMessage('upload-analysis-results', '\n2ï¸âƒ£ å‘é€è¯·æ±‚', 'info');
        const startTime = Date.now();

        try {
          const response = await fetch('/api/files/single', {
            method: 'POST',
            body: formData,
            headers: headers
          });

          const responseTime = Date.now() - startTime;
          logMessage('upload-analysis-results', `   å“åº”æ—¶é—´: ${responseTime}ms`, 'success');
          logMessage('upload-analysis-results', `   çŠ¶æ€ç : ${response.status}`, 'info');

          logMessage('upload-analysis-results', '\n3ï¸âƒ£ è§£æå“åº”', 'info');

          if (response.ok) {
            try {
              const responseData = await response.json();

              logMessage('upload-analysis-results', '   âœ… JSONè§£ææˆåŠŸ', 'success');
              logMessage('upload-analysis-results', `   å“åº”ç»“æ„: ${JSON.stringify(responseData, null, 2)}`, 'info');

              // æ¨¡æ‹ŸChatServiceé€»è¾‘
              logMessage('upload-analysis-results', '\n4ï¸âƒ£ ChatServiceé€»è¾‘æ¨¡æ‹Ÿ', 'info');

              if (responseData.success && responseData.data) {
                const uploadData = responseData.data;
                logMessage('upload-analysis-results', '   âœ… ChatServiceè§£ææˆåŠŸ', 'success');

                // è½¬æ¢ä¸ºå‰ç«¯æ ¼å¼
                const result = {
                  id: uploadData.id,
                  filename: uploadData.filename,
                  url: uploadData.url,
                  mime_type: uploadData.mime_type,
                  size: uploadData.size,
                  created_at: uploadData.created_at
                };

                logMessage('upload-analysis-results', `   è½¬æ¢ç»“æœ: ${JSON.stringify(result, null, 2)}`, 'success');
                logMessage('upload-analysis-results', '\nğŸ‰ å®Œæ•´æµç¨‹æˆåŠŸï¼', 'success');

              } else {
                logMessage('upload-analysis-results', '   âŒ ChatServiceè§£æå¤±è´¥', 'error');
                logMessage('upload-analysis-results', `   åŸå› : response.data.success=${responseData.success}, response.data.data=${!!responseData.data}`, 'error');

                generateFixRecommendations('parse_error', responseData);
              }

            } catch (jsonError) {
              logMessage('upload-analysis-results', `   âŒ JSONè§£æå¤±è´¥: ${jsonError.message}`, 'error');
              const text = await response.text();
              logMessage('upload-analysis-results', `   åŸå§‹å“åº”: ${text}`, 'error');

              generateFixRecommendations('json_error', { error: jsonError, response: text });
            }

          } else {
            logMessage('upload-analysis-results', `   âŒ HTTPé”™è¯¯: ${response.status} ${response.statusText}`, 'error');
            const errorText = await response.text();
            logMessage('upload-analysis-results', `   é”™è¯¯å†…å®¹: ${errorText}`, 'error');

            generateFixRecommendations('http_error', { status: response.status, error: errorText });
          }

        } catch (networkError) {
          logMessage('upload-analysis-results', `âŒ ç½‘ç»œé”™è¯¯: ${networkError.message}`, 'error');
          generateFixRecommendations('network_error', networkError);
        }

      } catch (error) {
        logMessage('upload-analysis-results', `âŒ åˆ†æå¤±è´¥: ${error.message}`, 'error');
      }
    }

    // ç”Ÿæˆä¿®å¤å»ºè®®
    function generateFixRecommendations(errorType, errorData) {
      const fixRecommendations = document.getElementById('fix-recommendations');
      const fixItems = document.getElementById('fix-items');

      fixItems.innerHTML = '';

      const fixes = [];

      switch (errorType) {
        case 'parse_error':
          fixes.push({
            icon: 'ğŸ”§',
            title: 'ä¿®å¤å“åº”è§£æé€»è¾‘',
            description: 'åç«¯å“åº”æ ¼å¼ä¸å‰ç«¯æœŸæœ›ä¸ç¬¦ï¼Œéœ€è¦è°ƒæ•´è§£æé€»è¾‘',
            code: `// æ£€æŸ¥å®é™…å“åº”æ ¼å¼å¹¶è°ƒæ•´
if (response.data && response.data.success !== undefined) {
    // å·²æœ‰æ­£ç¡®æ ¼å¼
    if (response.data.success && response.data.data) {
        return response.data.data;
    }
} else {
    // å¯èƒ½æ˜¯ç›´æ¥è¿”å›æ•°æ®ï¼Œéœ€è¦åŒ…è£…
    if (response.data && response.data.url) {
        return response.data; // ç›´æ¥è¿”å›æ•°æ®
    }
}`
          });
          break;

        case 'json_error':
          fixes.push({
            icon: 'ğŸ“',
            title: 'ä¿®å¤JSONæ ¼å¼é—®é¢˜',
            description: 'æœåŠ¡å™¨è¿”å›çš„ä¸æ˜¯æœ‰æ•ˆçš„JSONæ ¼å¼',
            code: `// å¢å¼ºJSONè§£æé”™è¯¯å¤„ç†
try {
    const data = await response.json();
    return data;
} catch (jsonError) {
    console.error('JSONè§£æå¤±è´¥:', jsonError);
    const text = await response.text();
    console.error('åŸå§‹å“åº”:', text);
    throw new Error('æœåŠ¡å™¨è¿”å›æ ¼å¼é”™è¯¯: ' + text);
}`
          });
          break;

        case 'http_error':
          fixes.push({
            icon: 'ğŸŒ',
            title: 'æ£€æŸ¥æœåŠ¡å™¨é…ç½®',
            description: 'HTTPçŠ¶æ€ç é”™è¯¯ï¼Œéœ€è¦æ£€æŸ¥æœåŠ¡å™¨ç«¯ç‚¹é…ç½®',
            code: `// æ£€æŸ¥Gatewayè·¯ç”±é…ç½®
// ç¡®ä¿ä»¥ä¸‹è·¯ç”±å­˜åœ¨:
- path: "/api/files/single"
  methods: ["POST"]
  upstream: "fechatter-server"
  
// æ£€æŸ¥åç«¯æœåŠ¡çŠ¶æ€
curl -X POST http://45.77.178.85:6688/api/files/single \\
     -H "Authorization: Bearer YOUR_TOKEN" \\
     -F "file=@test.txt"`
          });
          break;

        case 'network_error':
          fixes.push({
            icon: 'ğŸ”Œ',
            title: 'ç½‘ç»œè¿æ¥é—®é¢˜',
            description: 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œæ£€æŸ¥ç½‘ç»œå’ŒæœåŠ¡çŠ¶æ€',
            code: `// æ£€æŸ¥æœåŠ¡å™¨çŠ¶æ€
curl -I http://45.77.178.85:8080/health
curl -I http://45.77.178.85:6688/health

// æ£€æŸ¥Viteä»£ç†é…ç½®
proxy: {
  '/api': {
    target: 'http://45.77.178.85:8080',
    changeOrigin: true,
    secure: false,
  }
}`
          });
          break;
      }

      fixes.forEach(fix => {
        const fixItem = document.createElement('div');
        fixItem.className = 'fix-item';
        fixItem.innerHTML = `
                    <div class="fix-icon">${fix.icon}</div>
                    <div class="fix-content">
                        <div class="fix-title">${fix.title}</div>
                        <div class="fix-description">${fix.description}</div>
                        <div class="fix-code">${fix.code}</div>
                    </div>
                `;
        fixItems.appendChild(fixItem);
      });

      fixRecommendations.style.display = 'block';
    }

    // åˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', function () {
      setupFileDropZone();

      logMessage('upload-analysis-results', 'ğŸ¯ DAGå“åº”è§£æåˆ†æå·¥å…·å·²å°±ç»ª', 'info');
      logMessage('upload-analysis-results', 'ğŸ’¡ å»ºè®®ä¾æ¬¡è¿è¡Œå„é¡¹æµ‹è¯•æ¥å®šä½é—®é¢˜', 'info');
    });
  </script>
</body>

</html>