<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Raw SSE Event Monitor - Fechatter</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      background: #1e1e1e;
      color: #d4d4d4;
      margin: 0;
      padding: 20px;
    }

    .header {
      background: #0d7377;
      color: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .controls {
      background: #2d2d30;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .status {
      display: inline-block;
      padding: 5px 10px;
      border-radius: 4px;
      margin: 5px;
      font-weight: bold;
    }

    .connected {
      background: #4caf50;
      color: white;
    }

    .disconnected {
      background: #f44336;
      color: white;
    }

    .connecting {
      background: #ff9800;
      color: white;
    }

    button {
      background: #007acc;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }

    button:hover {
      background: #005a9e;
    }

    .event-log {
      background: #0c0c0c;
      border: 1px solid #404040;
      border-radius: 8px;
      padding: 15px;
      height: 600px;
      overflow-y: auto;
      font-size: 12px;
      line-height: 1.4;
    }

    .event-entry {
      margin: 5px 0;
      padding: 8px;
      border-left: 3px solid #404040;
      background: #1a1a1a;
      border-radius: 4px;
    }

    .event-raw {
      border-left-color: #17a2b8;
    }

    .event-parsed {
      border-left-color: #28a745;
    }

    .event-error {
      border-left-color: #dc3545;
    }

    .event-system {
      border-left-color: #6f42c1;
    }

    .timestamp {
      color: #6c757d;
      font-size: 11px;
    }

    .event-type {
      color: #ffc107;
      font-weight: bold;
    }

    .event-data {
      color: #e9ecef;
      margin-top: 5px;
      white-space: pre-wrap;
    }

    .stats {
      background: #2d2d30;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .stat-item {
      display: inline-block;
      margin: 5px 15px;
      color: #17a2b8;
    }
  </style>
</head>

<body>
  <div class="header">
    <h1>ğŸ” Raw SSE Event Monitor</h1>
    <p>ç›´æ¥ç›‘æ§ä»æœåŠ¡å™¨å‘é€çš„æ‰€æœ‰SSEäº‹ä»¶ï¼Œæ— æ¡†æ¶å¹²æ‰°</p>
  </div>

  <div class="controls">
    <span>è¿æ¥çŠ¶æ€ï¼š</span>
    <span id="connectionStatus" class="status disconnected">æ–­å¼€è¿æ¥</span>
    <button onclick="connect()">ğŸ”— è¿æ¥</button>
    <button onclick="disconnect()">âŒ æ–­å¼€</button>
    <button onclick="clearLog()">ğŸ—‘ï¸ æ¸…é™¤æ—¥å¿—</button>
    <button onclick="sendTestMessage()">ğŸ“¤ å‘é€æµ‹è¯•æ¶ˆæ¯</button>
  </div>

  <div class="stats">
    <span class="stat-item">æ€»äº‹ä»¶: <span id="totalEvents">0</span></span>
    <span class="stat-item">æˆåŠŸè§£æ: <span id="parsedEvents">0</span></span>
    <span class="stat-item">è§£æå¤±è´¥: <span id="failedEvents">0</span></span>
    <span class="stat-item">è¿æ¥æ—¶é•¿: <span id="connectionTime">0s</span></span>
    <span class="stat-item">æœ€åäº‹ä»¶: <span id="lastEventTime">æ— </span></span>
  </div>

  <div class="event-log" id="eventLog">
    <div class="event-entry event-system">
      <div class="timestamp">[ç³»ç»Ÿ] åŸå§‹SSEç›‘æ§å™¨å·²å¯åŠ¨</div>
      <div class="event-data">ç­‰å¾…è¿æ¥...</div>
    </div>
  </div>

  <script>
    let eventSource = null;
    let stats = {
      total: 0,
      parsed: 0,
      failed: 0,
      connectionStart: null
    };

    function log(message, type = 'system', data = null) {
      const eventLog = document.getElementById('eventLog');
      const entry = document.createElement('div');
      entry.className = `event-entry event-${type}`;

      const timestamp = new Date().toLocaleTimeString();
      entry.innerHTML = `
                <div class="timestamp">[${timestamp}] ${message}</div>
                ${data ? `<div class="event-data">${data}</div>` : ''}
            `;

      eventLog.appendChild(entry);
      eventLog.scrollTop = eventLog.scrollHeight;
    }

    function updateStats() {
      document.getElementById('totalEvents').textContent = stats.total;
      document.getElementById('parsedEvents').textContent = stats.parsed;
      document.getElementById('failedEvents').textContent = stats.failed;

      if (stats.connectionStart) {
        const duration = Math.floor((Date.now() - stats.connectionStart) / 1000);
        document.getElementById('connectionTime').textContent = duration + 's';
      }
    }

    function getToken() {
      // å°è¯•å¤šç§tokenè·å–æ–¹å¼
      const methods = [
        () => localStorage.getItem('auth_token'),
        () => window.__PINIA__?.state?.value?.auth?.token,
        () => window.tokenManager?.getAccessToken(),
        () => sessionStorage.getItem('auth_token')
      ];

      for (const method of methods) {
        try {
          const token = method();
          if (token) {
            log(`Tokenè·å–æˆåŠŸ: ${token.substring(0, 20)}...`, 'system');
            return token;
          }
        } catch (e) {
          // ç»§ç»­å°è¯•ä¸‹ä¸€ç§æ–¹æ³•
        }
      }

      log('âŒ æ— æ³•è·å–è®¤è¯token', 'error');
      return null;
    }

    function connect() {
      if (eventSource) {
        disconnect();
      }

      const token = getToken();
      if (!token) {
        return;
      }

      const url = `/events?access_token=${encodeURIComponent(token)}`;
      log(`ğŸ”— å°è¯•è¿æ¥SSE: ${url}`, 'system');

      try {
        eventSource = new EventSource(url);
        stats.connectionStart = Date.now();

        // è¿æ¥æ‰“å¼€
        eventSource.onopen = function (event) {
          document.getElementById('connectionStatus').className = 'status connected';
          document.getElementById('connectionStatus').textContent = 'å·²è¿æ¥';
          log('âœ… SSEè¿æ¥å·²å»ºç«‹', 'system');
          log(`è¿æ¥è¯¦æƒ…: ReadyState=${eventSource.readyState}, URL=${eventSource.url}`, 'system');
        };

        // æ¥æ”¶æ¶ˆæ¯ - è¿™æ˜¯å…³é”®ï¼
        eventSource.onmessage = function (event) {
          stats.total++;
          document.getElementById('lastEventTime').textContent = new Date().toLocaleTimeString();

          log(`ğŸ“¨ æ”¶åˆ°åŸå§‹SSEäº‹ä»¶`, 'raw', `åŸå§‹æ•°æ®:\n${event.data}`);

          try {
            const data = JSON.parse(event.data);
            stats.parsed++;

            log(`âœ… æˆåŠŸè§£æäº‹ä»¶`, 'parsed',
              `äº‹ä»¶ç±»å‹: ${data.type || 'æœªçŸ¥'}\n` +
              `å®Œæ•´æ•°æ®: ${JSON.stringify(data, null, 2)}`
            );

            // ç‰¹åˆ«æ£€æŸ¥NewMessageäº‹ä»¶
            if (data.type === 'NewMessage' || data.type === 'new_message') {
              log(`ğŸ¯ æ£€æµ‹åˆ°NewMessageäº‹ä»¶!`, 'parsed',
                `æ¶ˆæ¯ID: ${data.id || data.message_id}\n` +
                `å‘é€è€…: ${data.sender_id}\n` +
                `å†…å®¹: ${data.content || data.message}\n` +
                `èŠå¤©ID: ${data.chat_id}`
              );
            }

          } catch (e) {
            stats.failed++;
            log(`âŒ è§£æäº‹ä»¶å¤±è´¥: ${e.message}`, 'error', event.data);
          }

          updateStats();
        };

        // ç›‘å¬æ‰€æœ‰äº‹ä»¶ç±»å‹
        const eventTypes = ['message', 'NewMessage', 'new_message', 'MessageDelivered', 'message_delivered',
          'TypingStatus', 'typing_status', 'UserPresence', 'user_presence', 'ping'];

        eventTypes.forEach(eventType => {
          eventSource.addEventListener(eventType, function (event) {
            log(`ğŸ“¡ æ”¶åˆ°${eventType}äº‹ä»¶`, 'raw', event.data);
          });
        });

        // è¿æ¥é”™è¯¯
        eventSource.onerror = function (event) {
          document.getElementById('connectionStatus').className = 'status disconnected';
          document.getElementById('connectionStatus').textContent = 'è¿æ¥é”™è¯¯';

          log(`âŒ SSEè¿æ¥é”™è¯¯`, 'error',
            `ReadyState: ${eventSource ? eventSource.readyState : 'null'}\n` +
            `é”™è¯¯è¯¦æƒ…: ${JSON.stringify(event, null, 2)}`
          );
        };

      } catch (e) {
        log(`âŒ åˆ›å»ºEventSourceå¤±è´¥: ${e.message}`, 'error');
      }
    }

    function disconnect() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
        stats.connectionStart = null;
      }

      document.getElementById('connectionStatus').className = 'status disconnected';
      document.getElementById('connectionStatus').textContent = 'æ–­å¼€è¿æ¥';
      log('ğŸ”Œ SSEè¿æ¥å·²æ–­å¼€', 'system');
    }

    function clearLog() {
      document.getElementById('eventLog').innerHTML = '';
      stats = { total: 0, parsed: 0, failed: 0, connectionStart: stats.connectionStart };
      updateStats();
    }

    function sendTestMessage() {
      log('ğŸ“¤ å°è¯•å‘é€æµ‹è¯•æ¶ˆæ¯...', 'system');

      // å°è¯•é€šè¿‡chat storeå‘é€æ¶ˆæ¯
      if (window.chatStore && window.chatStore.sendMessage) {
        const testMessage = `Raw SSE Test ${Date.now()}`;
        window.chatStore.sendMessage(testMessage)
          .then(result => {
            log(`âœ… æµ‹è¯•æ¶ˆæ¯å‘é€æˆåŠŸ`, 'system',
              `æ¶ˆæ¯ID: ${result.message?.id}\n` +
              `å†…å®¹: ${testMessage}\n` +
              `ç°åœ¨ç›‘å¬åç«¯çš„SSEäº‹ä»¶...`
            );
          })
          .catch(error => {
            log(`âŒ æµ‹è¯•æ¶ˆæ¯å‘é€å¤±è´¥: ${error.message}`, 'error');
          });
      } else {
        log('âŒ ChatStoreä¸å¯ç”¨ï¼Œæ— æ³•å‘é€æµ‹è¯•æ¶ˆæ¯', 'error');
      }
    }

    // è‡ªåŠ¨è¿æ¥
    document.addEventListener('DOMContentLoaded', function () {
      log('ğŸš€ Raw SSEç›‘æ§å™¨å·²åŠ è½½', 'system');
      updateStats();

      // å¦‚æœæœ‰tokenï¼Œè‡ªåŠ¨è¿æ¥
      setTimeout(() => {
        if (getToken()) {
          connect();
        }
      }, 1000);
    });

    // æ›´æ–°è¿æ¥æ—¶é•¿
    setInterval(updateStats, 1000);

    // é¡µé¢å¸è½½æ—¶æ–­å¼€è¿æ¥
    window.addEventListener('beforeunload', disconnect);
  </script>
</body>

</html>