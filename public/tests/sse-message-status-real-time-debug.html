<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>🚀 SSE消息状态更新实时诊断</title>
  <style>
    body {
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }

    .diagnostic-container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 20px;
      text-align: center;
    }

    .title {
      font-size: 24px;
      font-weight: 600;
      margin: 0;
    }

    .subtitle {
      margin: 8px 0 0 0;
      opacity: 0.9;
    }

    .content {
      padding: 30px;
    }

    .section {
      margin-bottom: 30px;
      padding: 20px;
      border: 2px solid #f1f3f4;
      border-radius: 12px;
      background: #fafbfc;
    }

    .section-title {
      font-size: 18px;
      font-weight: 600;
      margin: 0 0 15px 0;
      color: #2d3748;
    }

    .diagnostic-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }

    .diagnostic-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      border-left: 4px solid #667eea;
    }

    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 8px;
    }

    .status-success {
      background: #48bb78;
    }

    .status-warning {
      background: #ed8936;
    }

    .status-error {
      background: #f56565;
    }

    .status-info {
      background: #4299e1;
    }

    .log-container {
      background: #1a202c;
      color: #e2e8f0;
      padding: 20px;
      border-radius: 8px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
      max-height: 400px;
      overflow-y: auto;
      margin-top: 10px;
    }

    .test-button {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      margin: 5px;
    }

    .test-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 16px rgba(102, 126, 234, 0.3);
    }

    .real-time-monitor {
      background: linear-gradient(135deg, #48bb78, #38a169);
      color: white;
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
    }

    .timeline {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .timeline-item {
      display: flex;
      align-items: center;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      border-left: 4px solid #fff;
    }

    .timeline-time {
      font-weight: 600;
      margin-right: 15px;
      min-width: 80px;
    }

    .error-analysis {
      background: linear-gradient(135deg, #f56565, #e53e3e);
      color: white;
      padding: 20px;
      border-radius: 12px;
      margin-top: 20px;
    }
  </style>
</head>

<body>
  <div class="diagnostic-container">
    <div class="header">
      <h1 class="title">🚀 SSE消息状态更新实时诊断系统</h1>
      <p class="subtitle">Deep Level Analysis for Message Status Icon Update Failures</p>
    </div>

    <div class="content">
      <!-- 实时监控面板 -->
      <div class="real-time-monitor">
        <h3>📡 实时SSE监控状态</h3>
        <div id="real-time-status">
          <div><span class="status-indicator status-info"></span>监控系统启动中...</div>
        </div>
      </div>

      <!-- 问题分析时间线 -->
      <div class="section">
        <div class="section-title">🔍 问题分析时间线</div>
        <div class="timeline" id="timeline">
          <!-- 动态填充 -->
        </div>
      </div>

      <!-- Vue响应式诊断 -->
      <div class="section">
        <div class="section-title">⚡ Vue响应式系统诊断</div>
        <div class="diagnostic-grid">
          <div class="diagnostic-card">
            <h4>Props更新检测</h4>
            <div id="props-update-status">
              <span class="status-indicator status-warning"></span>等待检测...
            </div>
          </div>
          <div class="diagnostic-card">
            <h4>Computed重新计算</h4>
            <div id="computed-recalc-status">
              <span class="status-indicator status-warning"></span>等待检测...
            </div>
          </div>
          <div class="diagnostic-card">
            <h4>DOM更新确认</h4>
            <div id="dom-update-status">
              <span class="status-indicator status-warning"></span>等待检测...
            </div>
          </div>
        </div>
      </div>

      <!-- 消息状态流转诊断 -->
      <div class="section">
        <div class="section-title">📨 消息状态流转诊断</div>
        <div id="message-status-flow">
          <!-- 实时更新 -->
        </div>
      </div>

      <!-- 测试控制面板 -->
      <div class="section">
        <div class="section-title">🧪 测试控制面板</div>
        <button class="test-button" onclick="simulateSSEConfirmation()">
          模拟SSE确认
        </button>
        <button class="test-button" onclick="forceVueUpdate()">
          强制Vue更新
        </button>
        <button class="test-button" onclick="checkDOMStatus()">
          检查DOM状态
        </button>
        <button class="test-button" onclick="analyzeResponseChain()">
          分析响应链
        </button>
      </div>

      <!-- 错误分析 -->
      <div class="error-analysis" id="error-analysis" style="display: none;">
        <h3>❌ 根本原因分析</h3>
        <div id="root-cause-analysis">
          <!-- 动态填充 -->
        </div>
      </div>

      <!-- 实时日志 -->
      <div class="section">
        <div class="section-title">📋 实时诊断日志</div>
        <div class="log-container" id="diagnostic-log">
          正在启动诊断系统...
        </div>
      </div>
    </div>
  </div>

  <script>
    class SSEStatusDiagnostic {
      constructor() {
        this.logs = [];
        this.timeline = [];
        this.messageStates = new Map();
        this.vueUpdateChain = [];
        this.init();
      }

      init() {
        this.log('🚀 SSE状态诊断系统启动');
        this.startRealTimeMonitoring();
        this.setupMessageInterception();
        this.setupVueUpdateMonitoring();
        this.startDOMObserver();
      }

      log(message, type = 'info') {
        const timestamp = new Date().toISOString().substr(11, 12);
        const logEntry = { timestamp, message, type };
        this.logs.push(logEntry);

        const logContainer = document.getElementById('diagnostic-log');
        const logLine = document.createElement('div');
        logLine.style.color = this.getLogColor(type);
        logLine.textContent = `[${timestamp}] ${message}`;
        logContainer.appendChild(logLine);
        logContainer.scrollTop = logContainer.scrollHeight;

        // 限制日志条数
        if (this.logs.length > 100) {
          this.logs.shift();
          logContainer.removeChild(logContainer.firstChild);
        }
      }

      getLogColor(type) {
        const colors = {
          info: '#e2e8f0',
          success: '#48bb78',
          warning: '#ed8936',
          error: '#f56565',
          debug: '#4299e1'
        };
        return colors[type] || colors.info;
      }

      addTimelineEvent(event, status = 'info') {
        const timestamp = new Date().toISOString().substr(11, 8);
        this.timeline.push({ timestamp, event, status });

        const timelineContainer = document.getElementById('timeline');
        const timelineItem = document.createElement('div');
        timelineItem.className = 'timeline-item';
        timelineItem.innerHTML = `
                    <div class="timeline-time">${timestamp}</div>
                    <div><span class="status-indicator status-${status}"></span>${event}</div>
                `;
        timelineContainer.appendChild(timelineItem);

        // 限制时间线条数
        if (this.timeline.length > 20) {
          this.timeline.shift();
          timelineContainer.removeChild(timelineContainer.firstChild);
        }
      }

      startRealTimeMonitoring() {
        this.log('📡 启动实时SSE监控');

        // 检查window.minimalSSE是否存在
        const checkSSE = () => {
          if (window.minimalSSE) {
            this.log('✅ 检测到minimalSSE服务', 'success');
            this.hookSSEEvents();
            document.getElementById('real-time-status').innerHTML =
              '<div><span class="status-indicator status-success"></span>SSE服务已连接</div>';
          } else {
            this.log('⚠️ 未检测到minimalSSE服务', 'warning');
            document.getElementById('real-time-status').innerHTML =
              '<div><span class="status-indicator status-warning"></span>SSE服务未连接</div>';
            setTimeout(checkSSE, 1000);
          }
        };

        checkSSE();
      }

      hookSSEEvents() {
        this.log('🔗 正在hook SSE事件监听器');

        if (window.minimalSSE && window.minimalSSE.on) {
          // 创建代理函数来监控所有SSE事件
          const originalOn = window.minimalSSE.on;
          window.minimalSSE.on = (event, handler) => {
            this.log(`🎯 检测到SSE事件监听器: ${event}`, 'debug');

            const wrappedHandler = (data) => {
              this.log(`📨 SSE事件触发: ${event}`, 'success');
              this.addTimelineEvent(`SSE事件: ${event}`, 'success');
              this.analyzeSSEData(event, data);
              return handler(data);
            };

            return originalOn.call(window.minimalSSE, event, wrappedHandler);
          };

          this.log('✅ SSE事件监听器hook完成', 'success');
        }
      }

      analyzeSSEData(event, data) {
        this.log(`🔍 分析SSE数据: ${JSON.stringify(data)}`, 'debug');

        if (event === 'message' && data.type === 'new_message') {
          this.trackMessageStatusUpdate(data);
        }
      }

      trackMessageStatusUpdate(data) {
        const messageId = data.id || data.message_id;
        this.log(`📍 追踪消息状态更新: ID=${messageId}`, 'info');

        this.messageStates.set(messageId, {
          receivedAt: Date.now(),
          status: 'sse_received',
          data: data
        });

        this.addTimelineEvent(`消息${messageId}: SSE确认接收`, 'success');

        // 检查Vue更新链
        this.checkVueUpdateChain(messageId);
      }

      checkVueUpdateChain(messageId) {
        this.log(`⚡ 检查消息${messageId}的Vue更新链`, 'debug');

        // 检查UnifiedMessageService
        setTimeout(() => this.checkUnifiedMessageService(messageId), 50);

        // 检查DOM更新
        setTimeout(() => this.checkDOMUpdate(messageId), 100);

        // 检查组件重渲染
        setTimeout(() => this.checkComponentRerender(messageId), 150);
      }

      checkUnifiedMessageService(messageId) {
        if (window.unifiedMessageService && window.unifiedMessageService.messagesByChat) {
          this.log(`🔄 检查UnifiedMessageService中的消息${messageId}`, 'debug');

          for (const [chatId, messages] of window.unifiedMessageService.messagesByChat.entries()) {
            const message = messages.find(m => m.id == messageId);
            if (message) {
              this.log(`✅ 在UnifiedMessageService中找到消息${messageId}, status=${message.status}`, 'success');
              this.updateStatusDiagnostic('props-update-status', '✅ Props已更新', 'success');

              if (message.status === 'delivered' || message.confirmed_via_sse) {
                this.addTimelineEvent(`消息${messageId}: UnifiedMessageService状态已更新`, 'success');
              } else {
                this.addTimelineEvent(`消息${messageId}: UnifiedMessageService状态未更新`, 'error');
                this.identifyVueUpdateIssue(messageId, message);
              }
              break;
            }
          }
        } else {
          this.log('❌ UnifiedMessageService不可用', 'error');
          this.updateStatusDiagnostic('props-update-status', '❌ Service不可用', 'error');
        }
      }

      checkDOMUpdate(messageId) {
        this.log(`🔍 检查消息${messageId}的DOM更新`, 'debug');

        const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
        if (messageElement) {
          const statusIcon = messageElement.querySelector('.h-4.w-4.text-green-500');
          const clockIcon = messageElement.querySelector('.h-4.w-4.text-blue-400');

          this.log(`📍 DOM状态检查: 绿色对号=${!!statusIcon}, 蓝色时钟=${!!clockIcon}`, 'debug');

          if (statusIcon) {
            this.updateStatusDiagnostic('dom-update-status', '✅ DOM已更新(绿色对号)', 'success');
            this.addTimelineEvent(`消息${messageId}: DOM显示绿色对号`, 'success');
          } else if (clockIcon) {
            this.updateStatusDiagnostic('dom-update-status', '⏰ DOM未更新(仍显示时钟)', 'warning');
            this.addTimelineEvent(`消息${messageId}: DOM仍显示时钟`, 'warning');
            this.diagnoseVueReactivityIssue(messageId, messageElement);
          } else {
            this.updateStatusDiagnostic('dom-update-status', '❓ DOM状态不明', 'error');
            this.addTimelineEvent(`消息${messageId}: DOM状态不明`, 'error');
          }
        } else {
          this.log(`❌ 找不到消息${messageId}的DOM元素`, 'error');
          this.updateStatusDiagnostic('dom-update-status', '❌ DOM元素不存在', 'error');
        }
      }

      diagnoseVueReactivityIssue(messageId, element) {
        this.log(`🔬 诊断消息${messageId}的Vue响应式问题`, 'warning');

        // 显示错误分析
        document.getElementById('error-analysis').style.display = 'block';

        const analysis = `
                    <h4>🎯 根本原因分析 - 消息ID: ${messageId}</h4>
                    <p><strong>问题现象:</strong> SSE确认已接收，但DOM中仍显示时钟图标而非绿色对号</p>
                    
                    <h4>🔍 可能原因:</h4>
                    <ul>
                        <li><strong>Vue响应式失效:</strong> 消息对象引用没有正确更新，Vue无法检测到变化</li>
                        <li><strong>Props传递延迟:</strong> 从Store到组件的props传递存在时机问题</li>
                        <li><strong>Computed缓存:</strong> isCurrentUserMessage或相关computed属性缓存未失效</li>
                        <li><strong>DOM渲染时机:</strong> Vue的异步渲染队列导致状态更新延迟</li>
                    </ul>
                    
                    <h4>🛠️ 建议修复方案:</h4>
                    <ul>
                        <li><strong>强制对象重新创建:</strong> 使用对象展开 {...message} 确保引用更新</li>
                        <li><strong>添加nextTick强制刷新:</strong> 在状态更新后使用nextTick + $forceUpdate</li>
                        <li><strong>增强响应式监听:</strong> 使用watchEffect监听消息状态变化</li>
                        <li><strong>DOM直接操作备用方案:</strong> 作为响应式失效的后备机制</li>
                    </ul>
                `;

        document.getElementById('root-cause-analysis').innerHTML = analysis;

        this.addTimelineEvent(`分析完成: Vue响应式问题确认`, 'error');
      }

      identifyVueUpdateIssue(messageId, message) {
        this.log(`🚨 识别Vue更新问题: 消息${messageId}状态=${message.status}`, 'error');

        // 具体问题分析
        const issues = [];

        if (!message.confirmed_via_sse) {
          issues.push('confirmed_via_sse字段未设置');
        }

        if (message.status !== 'delivered') {
          issues.push(`status仍为${message.status}而非delivered`);
        }

        this.log(`🔍 具体问题: ${issues.join(', ')}`, 'error');
        this.addTimelineEvent(`问题识别: ${issues.join(', ')}`, 'error');
      }

      updateStatusDiagnostic(elementId, message, status) {
        const element = document.getElementById(elementId);
        if (element) {
          element.innerHTML = `<span class="status-indicator status-${status}"></span>${message}`;
        }
      }

      checkComponentRerender(messageId) {
        this.log(`🎨 检查组件重渲染: 消息${messageId}`, 'debug');
        // 这里可以添加组件重渲染检测逻辑
        this.updateStatusDiagnostic('computed-recalc-status', '⏳ 检测中...', 'warning');
      }

      setupMessageInterception() {
        this.log('🎯 设置消息拦截器');
        // 可以在这里添加更多消息拦截逻辑
      }

      setupVueUpdateMonitoring() {
        this.log('⚡ 设置Vue更新监控');
        // 监控Vue的更新周期
      }

      startDOMObserver() {
        this.log('👁️ 启动DOM变化观察器');

        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' &&
              mutation.attributeName === 'data-status') {
              this.log(`🔄 检测到DOM属性变化: ${mutation.target.getAttribute('data-message-id')}`, 'debug');
            }
          });
        });

        // 观察整个document的变化
        observer.observe(document, {
          attributes: true,
          attributeFilter: ['data-status', 'data-confirmed-via-sse'],
          subtree: true
        });
      }
    }

    // 全局函数
    function simulateSSEConfirmation() {
      diagnostic.log('🧪 模拟SSE确认测试', 'debug');
      diagnostic.addTimelineEvent('手动触发: 模拟SSE确认', 'info');
    }

    function forceVueUpdate() {
      diagnostic.log('🔄 强制Vue更新测试', 'debug');
      diagnostic.addTimelineEvent('手动触发: 强制Vue更新', 'info');
    }

    function checkDOMStatus() {
      diagnostic.log('🔍 手动检查DOM状态', 'debug');
      diagnostic.addTimelineEvent('手动触发: DOM状态检查', 'info');
    }

    function analyzeResponseChain() {
      diagnostic.log('📊 分析响应链', 'debug');
      diagnostic.addTimelineEvent('手动触发: 响应链分析', 'info');
    }

    // 启动诊断系统
    const diagnostic = new SSEStatusDiagnostic();

    // 导出到全局供调试使用
    window.sseStatusDiagnostic = diagnostic;
  </script>
</body>

</html>